<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>工具人小方的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fxhstudy.com/"/>
  <updated>2024-06-03T13:32:59.674Z</updated>
  <id>https://fxhstudy.com/</id>
  
  <author>
    <name>工具人•小方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在MAC中安装ChatGPT</title>
    <link href="https://fxhstudy.com/article/d6c6a02f.html"/>
    <id>https://fxhstudy.com/article/d6c6a02f.html</id>
    <published>2024-06-03T07:48:00.000Z</published>
    <updated>2024-06-03T13:32:59.674Z</updated>
    
    <content type="html"><![CDATA[<font size="4"  face="PingFang SC"><p>MAC要安装ChatGPT桌面版的话，需要有两个要求，第一是需要M系列的芯片，第二是需要最新的MacOS<br>先去下面的网站下载ChatGPT桌面版</p><p><a href="https://persistent.oaistatic.com/sidekick/public/ChatGPT_Desktop_public_latest.dmg" target="_blank" rel="noopener" class="LinkCard">ChatGPT_Desktop_public_latest</a></p><p>接着就安装，但你打开时会loading一段时间，然后它会提示你没有权限。这时候可以再次打开，当处于loading界面，直接cmd+Q，强制退出，再次打开就完成了。</p><img src="https://qiniuyun.fxhstudy.com/ChatGPT_Desktop.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot;  face=&quot;PingFang SC&quot;&gt;

&lt;p&gt;MAC要安装ChatGPT桌面版的话，需要有两个要求，第一是需要M系列的芯片，第二是需要最新的MacOS&lt;br&gt;先去下面的网站下载ChatGPT桌面版&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
      <category term="ChatGPT" scheme="https://fxhstudy.com/categories/ChatGPT/"/>
    
    
      <category term="ChatGPT" scheme="https://fxhstudy.com/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>CV中常见的单词(持续更新中...)</title>
    <link href="https://fxhstudy.com/article/717e0e4f.html"/>
    <id>https://fxhstudy.com/article/717e0e4f.html</id>
    <published>2024-05-23T08:25:26.000Z</published>
    <updated>2024-05-28T14:51:23.302Z</updated>
    
    <content type="html"><![CDATA[<font size="4"><p>这段时间在学习计算机视觉相关的知识，我导虽然是网安学院的，但研究方向是人机交互方向，所以以后大概就和机器学习打交道了。我主要研究可能是和CV相关，这里就介绍一下CV相关的论文中一些常见的单词和概念。<br></font></p><font size="4" face="LXGW Wenkai Screen" ><h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><p>Parametric Approach：参数方法<br>Linear Classifier：线性分类器<br>Hard-Code：硬编码<br>Algorithm：算法<br>Data-Driven：数据驱动<br>Optimization：优化<br>Dataset：数据集<br>Classifier：分类器<br>Hyperparameters：超参数<br>Validation：验证集<br>Loss Function：损失函数<br>Multiclass SVM(Support Vector Machine) loss：多类支持向量机损失<br>Softmax：归一化指数<br>Regularization：正则化<br>Unnormalized：非归一化<br>Partial Derivatives：偏导数<br>Gradient：梯度<br>Stochastic Gradient Descent(SGD)：随机梯度下降<br>ConvNets/Convolutional Neural Network：卷积神经网络<br>Backpropagation：反向传播<br>Neural Networks：神经网络<br>N-layer Neural Net=(N-1-hidden-layer Neural Net)：两层神经网络=一层隐藏神经网络<br>Fully Connected Layer：全连接层<br>Convolution Layer：卷积层<br>Pooling Layer：池化层<br>Computational Graphs：计算图<br>Activation functions：激活函数<br>Data Preprocessing：数据预处理<br>Weight Initialization：权重初始化<br>Batch Normalization：批归一化<br>Overfit：过拟合<br>Cross-validation：交叉验证<br>Saddle Points：鞍点<br>Momentum：动量<br>AdaGrad/Adaptive Gradient：自适应梯度算法</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Softmax：给定一系列类别，softmax可以给出某输入被划分到各个类别的概率分布。<br>Iteration：表示1次迭代，每次迭代更新1次网络结构的参数；<br>Batch-size：1次迭代所使用的样本量；<br>Epoch：1个epoch表示过了1遍训练集中的所有样本。</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot;&gt;

&lt;p&gt;这段时间在学习计算机视觉相关的知识，我导虽然是网安学院的，但研究方向是人机交互方向，所以以后大概就和机器学习打交道了。我主要研究可能是和CV相关，这里就介绍一下CV相关的论文中一些常见的单词和概念。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;font
      
    
    </summary>
    
    
      <category term="计算机视觉" scheme="https://fxhstudy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="计算机视觉" scheme="https://fxhstudy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>二战(终章)</title>
    <link href="https://fxhstudy.com/article/1b18cc45.html"/>
    <id>https://fxhstudy.com/article/1b18cc45.html</id>
    <published>2024-04-02T15:51:29.000Z</published>
    <updated>2024-04-02T17:01:18.947Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC">终于结束了，西电今年网安一共收62个学硕，复试进了80人。初试成绩排名60，复试成绩排名15(笔试83、面试80)，总成绩排名31。可以说是复试极限逆袭了，不出意外的话，应该是上岸了。<br><p>说实话，二战压力真的很大，不论是学业上的从数二英二转到数一英一，还是心理上不断自我否定的压力，真的很痛苦！<br></p><p>但一切都结束了，最后的结果也是值得的！<br></p><p>这两年的备考收获了很多，不论是英语还是专业课的知识，甚至解决问题的能力都大幅度上升。<br></p><p>虽然这两年也有一些遗憾，但总体来说，结局是好的，也选了一个大牛导师，一切都在往好的方向发展！<br></p><p>备考时，曾多次想过，如果我上岸了，会有多激动。但当真正知道排名的那一刻，其实内心并没有太多波澜，因为我知道这是我应得的。在出复试门的那一刻起，我就知道，这学我上定了。<br></p><p>之前考完时，也写了一篇关于二战的文章，两篇文章的背景都是Running。这里其实想说，一直奔跑下去，虽然前路会遇到很多困难与挫折，但请坚持下去，KEEP RUNNING KEEP FIGHTING!</p><p>我很喜欢一句话：Fake it till you make it，这也是我微信的个性签名。初试时，我会去想，如果我是一名研究生，我有哪些不足的地方需要去注意。在复试时，我会去思考，如果我是一名研究生，面对老师的提问时，我会怎么回答。假装自己是一名研究生，假装自信直到自己变得自信为止，这个过程中，伴随着是自己不断的学习成长，把原来不自信的状态替换掉，用身体动作来向思想暗示，让自己的大脑相信这件事情。听起来可能有些滑稽，但对我而言，一直鼓舞着我不断前进，希望这句话也能给你带来一些思考。</p><p>最后就是这样了，终于，总算是结束了这一阶段的路程了！这一路确实很不容易，但算是比较圆满了。很快就会迎来下一阶段的挑战了，未来是光明的，也是充满挑战的！</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;
终于结束了，西电今年网安一共收62个学硕，复试进了80人。初试成绩排名60，复试成绩排名15(笔试83、面试80)，总成绩排名31。可以说是复试极限逆袭了，不出意外的话，应该是上岸了。&lt;br&gt;

&lt;p&gt;说实话，
      
    
    </summary>
    
    
      <category term="考研" scheme="https://fxhstudy.com/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="考研" scheme="https://fxhstudy.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>进程同步问题</title>
    <link href="https://fxhstudy.com/article/92a2269f.html"/>
    <id>https://fxhstudy.com/article/92a2269f.html</id>
    <published>2024-03-11T12:54:56.000Z</published>
    <updated>2024-04-02T15:49:25.293Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><h2 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h2><p>设自行车生产线上有一个箱子，其中有N个位置（N≥3），每个位置可存放一个车架或者一个车轮，设有3名工人，其活动分别为：<br>工人1活动：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br> 加工一个车架；<br> 车架放入箱中；<br>&#125;<br><br>工人<span class="hljs-number">2</span>活动：<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br> 加工一个车轮；<br> 车轮放入箱中；<br>&#125;<br><br>工人<span class="hljs-number">3</span>活动：<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br> 箱中取一个车架；<br> 箱中取两个车轮；<br> 组装为一辆车；<br>&#125;<br></code></pre></div></td></tr></table></figure><p>要求分别用信号量PV操作实现三名工人的合作，要求解中不含死锁。</p><p>算是比较经典的进程同步问题了，也是在刷复试学校历年真题的时候遇到的。难度不大，但有一些细节，对于进程同步问题不熟悉的同学，可能会忽略，所以这里记录一下。<br>首先分析题目，一个箱子可以放N个零件，工人1一次放一个车架，工人2一次放一个车轮，工人3要做的是从箱子里拿出零件，然后组装车，但<code>第一个需要注意的点是</code>一辆车需要两个车轮和一个车架。<br>知道题目的要求之后，我们需要考虑此题目中，需要哪些信号量。<br>1、箱子可以放N个零件，这里我们设empty=N，代表最多可以放置N个零件。<code>第二个需要注意的点是</code>，有的人可能会再设一个mutex来互斥访问箱子，但这里其实是没有必要的，也是新手经常犯的一个错误。因为P、V操作都是原语，而原语是不可中断的程序段。而此题，当对empty进行PV操作时，其实以及实现了对箱子的互斥操作。<br>2、接着我们设置frame=0和wheel=0信号量来表示，箱子中车架和车轮的数量。<br>3、<code>第三个需要注意的的点是</code>，程序可能出现，箱子里面全是车轮或者车架，所以我们要分别设定信号量来保证避免这种情况。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">semaphore empty=N;<span class="hljs-comment">//箱子内的空位</span><br>semaphore weel=<span class="hljs-number">0</span>;<span class="hljs-comment">//车轮</span><br>semaphore frame=<span class="hljs-number">0</span>;<span class="hljs-comment">//车架</span><br>semaphore s1=N<span class="hljs-number">-2</span>;<span class="hljs-comment">//车架最大值</span><br>semaphore s2=N<span class="hljs-number">-1</span>;<span class="hljs-comment">//车轮最大值</span><br> <br>工人<span class="hljs-number">1</span>活动：<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br> 加工一个车架；<br> P(empty);<br> P(s1);<br> 车架放入箱中；<br> V(frame);<br>&#125;<br> <br>工人<span class="hljs-number">2</span>活动：<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br> 加工一个车轮；<br> P(empty);<br> P(s2);<br> 车轮放入箱中；<br> V(wheel);<br>&#125;<br> <br>工人<span class="hljs-number">3</span>活动：<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br> P(frame);<br> 箱中取一个车架；<br> V(empty);<br> V(s1);<br> P(wheel);<br> P(wheel);<br> 箱中取两个车轮；<br> V(empty);<br> V(empty);<br> V(s2);<br> V(s2);<br> 组装为一辆车；<br>&#125;<br></code></pre></div></td></tr></table></figure><p>把一些注意点弄清楚了，代码其实就不难写了。</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;

&lt;h2 id=&quot;进程同步问题&quot;&gt;&lt;a href=&quot;#进程同步问题&quot; class=&quot;headerlink&quot; title=&quot;进程同步问题&quot;&gt;&lt;/a&gt;进程同步问题&lt;/h2&gt;&lt;p&gt;设自行车生产线上有一个箱子，其中有N
      
    
    </summary>
    
    
      <category term="考研" scheme="https://fxhstudy.com/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="考研" scheme="https://fxhstudy.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>mac系统下，Clion环境配置的问题</title>
    <link href="https://fxhstudy.com/article/2806f2d2.html"/>
    <id>https://fxhstudy.com/article/2806f2d2.html</id>
    <published>2024-03-11T12:53:51.000Z</published>
    <updated>2024-04-02T15:49:39.166Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><h2 id="mac系统下，Clion环境配置的问题"><a href="#mac系统下，Clion环境配置的问题" class="headerlink" title="mac系统下，Clion环境配置的问题"></a>mac系统下，Clion环境配置的问题</h2><p>最近在准备复试，计算机专业基本上复试都需要上机的，好在报考的学校网安机试很简单，限定C。<br>因为现在mac系统用的多了，所以准备在mac系统上去刷一些题。难受的是之前因为嫌Xcode太大了，就卸载了。<br>但mac系统上你如果想运行C，或者通过Clion去运行的话，需要gcc和cmake。网上大部分的文章的解决办法其实都是先下载Xcode，然后通过Xcode中带有相应的环境，这时候就可以了。<br>但也正像我之前所说，Xcode是非常大的(十几个G)，平时也不会去用，于是查了一下有没有别的解决办法，于是就有了这篇文章。</p><p>问题是这样的，我在下载完Clion后，发现Clion不自带c语言运行环境</p><p><img src="https://qiniuyun.fxhstudy.com/Clion_img1.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>所以需要自己去配置<br>首先，就是下载homebrew，这个是用于安装mac上缺少的各种软件的。如果自己操作的话，可能还需要自己安装一些其他的东西，接下来要用到的brew，就是通过它来自动安装的。在命令行输入以下代码即可：</p></font><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">/bin/zsh -c <span class="hljs-string">"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"</span><br></code></pre></div></td></tr></table></figure><font size="4" face="PingFang SC">回车之后，他会让你选个源，这里随便选一个就行(因为在国内有些网站访问不了或者网速不行)。<p><img src="https://qiniuyun.fxhstudy.com/Clion_img2.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>接着跳过即可。</p><p>然后接着就是安装gcc和cmake了，分别输入以下命令：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">brew install gcc<br>brew install cmake<br></code></pre></div></td></tr></table></figure><p><img src="https://qiniuyun.fxhstudy.com/Clion_img3.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>到这里，c语言运行环境就配置好了。<br>接着就是手动将环境路径，添加到Clion中。<br>但百度很难找到关于查看gcc compiler路径的命令，但办法总比困难多</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">brew <span class="hljs-built_in">list</span> gcc<br></code></pre></div></td></tr></table></figure><p><img src="https://qiniuyun.fxhstudy.com/Clion_img4.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>这里记下gcc和g+/+的路径<br>然后将copy到Clion中就大功告成了</p><p><img src="https://qiniuyun.fxhstudy.com/Clion_img5.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>最后运行成功</p><p><img src="https://qiniuyun.fxhstudy.com/Clion_img6.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>很简单的一次环境配置，第一次是在mac mini上配置了一次，第二次在macbook上配置时，又不记得了，所以索性就记录了一下</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;

&lt;h2 id=&quot;mac系统下，Clion环境配置的问题&quot;&gt;&lt;a href=&quot;#mac系统下，Clion环境配置的问题&quot; class=&quot;headerlink&quot; title=&quot;mac系统下，Clion环境配置的问
      
    
    </summary>
    
    
      <category term="考研" scheme="https://fxhstudy.com/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="考研" scheme="https://fxhstudy.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>如何自己购买最新美漫期刊</title>
    <link href="https://fxhstudy.com/article/a46da21b.html"/>
    <id>https://fxhstudy.com/article/a46da21b.html</id>
    <published>2024-01-03T14:44:05.000Z</published>
    <updated>2024-01-05T08:14:52.733Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><p>算是一个比较有趣的话题了，之前看大爆炸的时候，喜欢上了看美漫，但最新的美漫基本上很难在国内渠道买到，能买到的基本上都是汉化的，并且是出来很久的了。</p><p>于是我就在网上寻找如何自己购买最新期刊，说实话，网上关于这类的信息是比较少的，要么就是建议购买已经汉化的美漫，要么就是淘宝店代购，但种类非常有限。</p><p>但终于，功夫不负有心人，微博上真的有大佬用海淘的方法，购买成功，并且写了篇博文</p><a href="https://weibo.com/ttarticle/x/m/show/id/2309404350869305987731?_wb_client_=1" target="_blank" rel="noopener" class="LinkCard">从零开始，自己订购实体美漫期刊</a><p>这篇博文介绍得非常详细了，介绍了相关的方法。去年三月份的时候，我按照博文的流程，进行了一次期刊的订阅，大概两周的时间，七本期刊就到了，平均算下来是五十一本，比淘宝代购的价格便宜不少，毕竟没有中间商赚差价：）。感觉还是挺有意思的，以后海淘按照这个思路，应该基本上都可以成功，这里记录一下。</p><p>首先海淘是肯定需要一张国际信用卡的，这里我是申请了一张虚拟信用卡。上面的博文很详细地介绍了怎么申请，不过我建议如果有机会的话，还是申请一张实体的，有概率检测出来是虚拟卡，导致不能交易。如果你经常需要订阅国外软件或者购物的，其实可以申请一张，我之前订阅一些国外软件的时候，申请的虚拟卡都是可以用的，比如ChatGPT的订阅就可以用到。</p><p>接着你要知道两个网站，一个是期刊购买的网站，另一个是转运仓。</p><p>这里说一下流程，首先你得确定一个转运品牌，接着他会给你一个转运仓的地址，你在期刊网站购买了期刊，将转运仓的地址填写在这个网站，然后，期刊会发到这个转运仓，当转运仓收到快递后，会进行审核，审核通过后会发往大陆口岸。接着就是清关，如果运气不好，清关时被选中了，那么这次海淘的花费的时间会被无限拉长，有的清关可能会耗费几个月，有的可能就拿不到了。不过我当时清关就花了半个小时，非常快了。清关通过后，流程就和平时快递的流程是一样的了。</p><p>首先，先选好转运仓，因为后面在美刊网站注册账号的时候需要填写相关信息，我看评论有的人走了转运四方，查了一下，存在丢失的情况，这里我选的是顺丰的转运仓，虽然贵一点，但比较靠谱。</p><a href="https://www.sfbuy.com/" target="_blank" rel="noopener" class="LinkCard">顺丰</a><p>先填写相关信息，注意，这里需要上传你的身份证，进行认证才可以。填写完相关信息后，就会给你转运仓的地址，这个地址后面在期刊网站填写信息的时候需要用到。</p><p><img src="https://qiniuyun.fxhstudy.com/%E6%9C%9F%E5%88%8A7.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>接着就是期刊网站了，这里我用的也是博文介绍的美漫期刊网站，里面有很多最新的期刊，算是非常全的了，而且价格也不贵，还有很多折扣的漫画。</p><a href="https://www.midtowncomics.com/" target="_blank" rel="noopener" class="LinkCard">midtowncomics</a><p>需要先创一个账户，博文介绍得也非常详细了，</p><p>这些是我买的漫画，一共37.5刀乐</p><p><img src="https://qiniuyun.fxhstudy.com/%E6%9C%9F%E5%88%8A4.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p><img src="https://qiniuyun.fxhstudy.com/%E6%9C%9F%E5%88%8A5.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p><img src="https://qiniuyun.fxhstudy.com/%E6%9C%9F%E5%88%8A6.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>这里注意，期刊发货到转运仓也是需要收费的，这里选择最便宜的就可以了。还有一点，清关的时候，超过一定的重量和刊数，是会收取关税的，好像图书是十本以下，所以我当时买了七本，就没有收取关税了。</p><p>下单完成后，你需要去转运仓添加包裹，填写的要求，也可以去那篇博文看看，这里我就不多介绍了。</p><p><img src="https://qiniuyun.fxhstudy.com/%E6%9C%9F%E5%88%8A8.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>期刊加上到转运仓的费用是260+，运费是110+，最后花费了370，七本期刊，平均五十多一刊，相对而言还是比较划算的。我是3/17号下单的，3/30号收到，将近两个星期。</p><p>这就是我自己购买最新期刊的经历，海淘其实也可以按照这个流程来，难度也不大。</p><p>当然，如果你不想这么麻烦，也不要求最新的期刊，只是想看美漫，那你可以去闲鱼上搜索美漫，有很多专门卖这种的，但期刊有限，只能从他那有的里面挑选，而且最新期刊价格也高达70-80一刊，算是很贵的了。当然，如果你只想看电子版的，不用来收藏，只是对情节感兴趣的话，这里介绍一个非常🐮的网站</p><a href="https://getcomics.org/" target="_blank" rel="noopener" class="LinkCard">getcomics</a><p>这个网站你能找到最新的期刊，是实时更新的。并且除了DC和MARVEL，还有很多其他的美漫，都是电子版而且是免费的，可以下载，也可以在线观看，适合我这种穷学生。当然如果你想支持正版的话，可以去官网订阅电子版，不过一刊的价格也不便宜。</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;
&lt;p&gt;算是一个比较有趣的话题了，之前看大爆炸的时候，喜欢上了看美漫，但最新的美漫基本上很难在国内渠道买到，能买到的基本上都是汉化的，并且是出来很久的了。&lt;/p&gt;
&lt;p&gt;于是我就在网上寻找如何自己购买最新期刊，说
      
    
    </summary>
    
    
      <category term="日常" scheme="https://fxhstudy.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>SSL证书更换</title>
    <link href="https://fxhstudy.com/article/74e856a1.html"/>
    <id>https://fxhstudy.com/article/74e856a1.html</id>
    <published>2024-01-01T05:24:52.000Z</published>
    <updated>2024-01-05T08:15:52.926Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><p>这几天不是年初了嘛，博客每年的域名证书都需要更换，但一年更换一次，导致第二年都需要再找资料看看流程，非常麻烦。所以这里写一篇博客，记录一下，下次更换的时候也方便。</p><p>我的博客图像是存储在七牛云上的，每年大概几块钱吧，也不算太贵，但也需要一个二级域名用来指向你的云存储。</p><p>我的顶级域名是在阿里云买的，一年大概几十块钱，一个静态博客网站，也就域名花钱，价格也不贵。</p><p>前几天收到SSL证书要失效的邮件，所以登录七牛云看了一下</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_1.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>这里就是要更换一下SSL证书，SSL用在IP层，主要是保密和认证作用，这个算是网安的知识点，感兴趣可以去了解一下。</p><p>先找到SSL证书，在证书管理里面购买证书</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_2.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_3.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>当然，我们的个人博客，肯定是要免费的证书。不过我看了一下，不管是七牛云还是阿里云的免费证书都由一年有效期变成了三个月，也就是以后是三个月要换一次证书。。。有点难受了</p><p>接着就是补全信息，填写一些信息，这里域名是你的顶级域名，证书备注名就是你的二次域名。</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_4.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>公司信息这一块要求不严格，可以按照我这样写，基本上都会通过，我怀疑这一块都不会看</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_5.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>这里部署证书先不用管，直接提交就行了</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_6.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>但检测没有通过，显示域名所有权验证未通过</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_7.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>这是因为他不知道你的域名是不是你的，所以这里要域名解析，也就是在阿里云中，去增加一条主机记录(注意，这是因为我在阿里云买的顶级域名，如果你在腾讯云买的，就需要去腾讯云解析)</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_8.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>直接点击添加记录，然后添加相关信息就可以了</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_9.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_16.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>记录类型填的是CNAME，其他的就和你配置域名的时候的记录是一样的</p><p>这些做完之后，基本上就没有太大的问题了，等一两分钟，基本上就通过了</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_10.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_11.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>这里点击部署，过一两分钟后基本上就通过了</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_12.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_14.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>到这里七牛云的证书更换基本上就完成了</p><p>接下来就是顶级域名的证书部署了，也就在阿里云里面操作了</p><p>看一下阿里云的提示</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_13.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>然后购买证书，当然这里也肯定是免费的了</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_15.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>我去年用的证书，今年要收费了，难受，这能用这种测试的证书，不过除了期限变为了三个月，其他没有变化</p><p>接着就是更换证书</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_17.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>填写相关信息</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_20.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>提交过后就会进行审核了，过几分钟基本上就通过了</p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_18.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p><img src="https://qiniuyun.fxhstudy.com/SSL%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2_19.png" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>到这里，七牛云和阿里云的域名部署基本上就完成了，只是相比去年，以后每三个月都要换一下证书还是挺麻烦的</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;


&lt;p&gt;这几天不是年初了嘛，博客每年的域名证书都需要更换，但一年更换一次，导致第二年都需要再找资料看看流程，非常麻烦。所以这里写一篇博客，记录一下，下次更换的时候也方便。&lt;/p&gt;
&lt;p&gt;我的博客图像是存储在七
      
    
    </summary>
    
    
      <category term="博客" scheme="https://fxhstudy.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://fxhstudy.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>二战</title>
    <link href="https://fxhstudy.com/article/undefined.html"/>
    <id>https://fxhstudy.com/article/undefined.html</id>
    <published>2023-12-26T13:27:00.000Z</published>
    <updated>2024-01-03T08:09:28.000Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC">    今年应该是很有很大机会上岸的！</br>    是的，我二战了，这也是我很久没有更新的原因。</br>    从今年五月份开始，我就在准备二战了。</br>    说实话，一战失败之后，我确实非常失落，努力了一年，最后以失败收场。</br>    可能是目标太高，也可能是我的准备不足，但最终结果就是我没上岸。</br>    没有人在乎你付出了多少，结果永远是决定你的努力</br>    我也不喜欢给我自己找借口，因为我也只相信结果，结果就是你不行</br>    二战压力大吗？二战的压力很大，我压力最大的时候就是在考研结果下来的时刻，那时候天天脑子里面都是要怎么办，甘不甘心就这样，每天在各种论坛上看二战心得，那段时间真的很压抑，算是我最迷茫的时候了。是工作还是二战？基本上每天醒来，都要对着天花板望好久，周围的朋友有考上的，有调剂的，有工作的。当时觉得大家都在进步，只有自己在原地踏步。去年的成绩也可以调剂走，但我每在有这个念头的时候，总会问自己，去了这个学校，你不会后悔吗？很痛苦！</br>    考研真的很痛苦，这只有考过的人才能深刻体会到，可以说它比高考还要残酷，高考即便发挥失常，你也有书可以读。但考研只有一次机会，基本没有容错，如果你是应届生，那意味着你失去了最好的校招的机会，如果你是往届生，那意味着你失去了应届生的身份，代价很大。过去努力一年的时间，都在这一场考试中了，他就像赌博，花上一年的时间，去赌一场考试。考上了，满载而归，考不上，一无所获。而大部分人都是一无所获的</br>    同样，你也会遇到很多困难，一遍又一遍的否认自己，但又一遍又一遍地重新面对，这个过程会极度痛苦，自我折磨，痛苦地你不会想再去经历，这就是为什么二战需要很大的勇气了。我很佩服我自己，我努力了两年，我做到了很多人没有做到的事。我也很佩服每一位上岸的研究生，因为他们和我所经历的一样。</br>    这是一场一个人的战争，考研注定是孤独的，不会有人和同行，同行的都是你的竞争对手，你需要自己去战斗，这很残酷，也是事实。但我认为只要战斗到最后，你就是勇士，不论结果如何。这可能有点鸡血，但我经历过两年，我深深知道其中的难。</br>    最后一个月的我，每天都在担心自己会不会感冒，早上是不是要再早起一点，进度会不会跟不上，还有哪些需要调整等等，这些说起来容易，但每天都在经历这些反复折磨，真的很痛苦，你可以去问问每一位上岸的研究生，考研苦不苦。</br>    这是我最后一次考研了，不论结果如何，我尽力了。</br></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;
    今年应该是很有很大机会上岸的！&lt;/br&gt;
    是的，我二战了，这也是我很久没有更新的原因。&lt;/br&gt;
    从今年五月份开始，我就在准备二战了。&lt;/br&gt;
    说实话，一战失败之后，我确实非常
      
    
    </summary>
    
    
      <category term="考研" scheme="https://fxhstudy.com/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="考研" scheme="https://fxhstudy.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>mac</title>
    <link href="https://fxhstudy.com/article/1713eb65.html"/>
    <id>https://fxhstudy.com/article/1713eb65.html</id>
    <published>2023-02-04T09:41:40.000Z</published>
    <updated>2023-02-04T11:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><p>开学的时候更换了mac生产力，用了一段时间后，发现确实还可以，就是感觉生态没有Windows系统好，而且很多软件做得都不是很好。。。</p><p>不过mac系统上一些软件还是很好用的，但你会发现mac上很多软件都是需要订阅你才可以用，而有些订阅可能价格还比较贵，就很难受了。</p><p>以上的去年年初的想法，现在其实我比较支持为好用的软件付费的，当然是我认为能用的上的软件，</p><p>废话不多说，这篇我就介绍一下，我用起来不错的几款比较高效的工具</p><p>&nbsp;</p><h3 id='effie★★★★★'>Effie「★★★★★」</h3><p>放在第一位的是一款写作软件，Win、Mac、iPhone以及Android版本都有，如果你用的不是Mac，可以选择Win版本。这款软件可以说是我从Win到Mac用过最好的写作软件了，最开始写博客用的是Sublime，然后再到Typora，但Effie的排版以及界面吸引了我，就和它介绍的一样沉浸写作，确实非常推荐。不订阅的话和订阅其实差别都不大，我就属于没有订阅，白嫖那一类，哈哈</p><p><img src="https://qiniuyun.fxhstudy.com/Effie.PNG" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>界面真的是设计得太好看了，强烈推荐(这里绝不是打广告)。</p><p>&nbsp;</p><h3 id='downie★★★★★'>Downie「★★★★★」</h3><p>强烈推荐，可以下载网页中的视频，包括bilibili，YouTube等等，个人认为是mac上极少数令我非常满意的软件。这款软件需要收费，买断制，小版本可以免费更新。虽然用到的不频繁，但用到的时候你会很感谢有这款软件。</p><p><img src="https://qiniuyun.fxhstudy.com/Downie.PNG" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h3 id='iina★★★★☆'>IINA「★★★★☆」</h3><p>免费视频播放软件里面算是很好的了，IINA这款软件很简洁。我之前有付费买断一个叫OmniPlayer的软件，挺多人说还好，我就买了。。。但现在我主要用的还是IINA，这款软件界面和功能都挺不错。关键是这款软件，可以直接使用URL来观看网页中的视频，而OmniPlayer虽然也有这个功能，但是很多都是识别错误。。。(Win可以使用PotPlayer，我用到现在最好的视频播放软件了，自由度很高，强烈推荐)</p><p><img src="https://qiniuyun.fxhstudy.com/IINA.PNG" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h3 id='motri★★★☆☆'>Motri「★★★☆☆」</h3><p>算是迅雷的替代品吧，没有钱就选这个，如果能在网上找比较好的Tracker 服务器资源，那基本上就是充了钱的迅雷，还是得看运气。我现在看美剧下载的种子就是用这个软件，用了挺久的了，总体来讲，有好的Tracker 服务器资源，即便是比较偏的资源，速度也能上到2~3M/s,比迅雷好。</p><p><img src="https://qiniuyun.fxhstudy.com/Motri.PNG" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h3 id='qbittorrent★★☆☆☆'>qBittorrent「★★☆☆☆」</h3><p>和Motri作用一样，个人更加喜欢Motri的界面，所以这个很少用，这个更适合爱折腾的用户，功能更多。</p><p><img src="https://qiniuyun.fxhstudy.com/qBittorrent.PNG" srcset="/img/loading.gif" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>&nbsp;</p><p>以上除了Effie和qBittorrent，基本上都是Mac独占的，都是用起来比较好用的软件，还有一些软件刚用一段时间，后续可能会继续更新。</p><p>&nbsp;</p><p>&nbsp;</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;
&lt;p&gt;开学的时候更换了mac生产力，用了一段时间后，发现确实还可以，就是感觉生态没有Windows系统好，而且很多软件做得都不是很好。。。&lt;/p&gt;
&lt;p&gt;不过mac系统上一些软件还是很好用的，但你会发现mac上
      
    
    </summary>
    
    
      <category term="效率" scheme="https://fxhstudy.com/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="效率" scheme="https://fxhstudy.com/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>二进制深度思考</title>
    <link href="https://fxhstudy.com/article/b85d5ece.html"/>
    <id>https://fxhstudy.com/article/b85d5ece.html</id>
    <published>2023-02-04T09:41:33.000Z</published>
    <updated>2023-02-04T11:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="之前也写过一些有关于二进制的文章，但总感觉有一些地方没有真正了解其意义。备考期间，仔细查阅了一些资料，这里记录一下。"><a href="#之前也写过一些有关于二进制的文章，但总感觉有一些地方没有真正了解其意义。备考期间，仔细查阅了一些资料，这里记录一下。" class="headerlink" title="之前也写过一些有关于二进制的文章，但总感觉有一些地方没有真正了解其意义。备考期间，仔细查阅了一些资料，这里记录一下。"></a>之前也写过一些有关于二进制的文章，但总感觉有一些地方没有真正了解其意义。备考期间，仔细查阅了一些资料，这里记录一下。</h2><font size="4" face="PingFang SC"><p>关于负数底层为什么是取反加一</p><p>在实现硬件的加减乘除时，每一个运算用的是一套逻辑运算规则。</p><p>目的就是为了使正负相加时，得出正确的结果，所以采用了负数取反加一的策略。</p><p>&nbsp;</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 输出二进制</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &amp;gt; <span class="hljs-number">0</span>; i--)&#123;<br>        System.out.print((num &amp;amp; (i&amp;lt;&amp;lt;<span class="hljs-number">32</span>)) == <span class="hljs-number">0</span> ? &amp;quot;<span class="hljs-number">0</span>&amp;quot; : &amp;quot;<span class="hljs-number">1</span>&amp;quot;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><p>5 --&gt; 0000 0101</p><p>-5--&gt; 1111 1011</p><p>&nbsp;</p><p>4  --&gt; 0000 0100</p><p>-4 --&gt; 1111 1100</p><p>   --&gt;  0000 0100</p><p>&nbsp;</p><p>1111 1011</p><p>0000 0101</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>tips: 补码真正的含义是 模 - 原码的绝对值</p><p>补码--让减法操作转变为加法操作，节省硬件成本</p><p>&nbsp;</p><p>&nbsp;</p><p>根据数论中模的性质，运算器采用模的性质将减法采用加法实现</p><p>例如 原码  0010 1011  有符号数表示 43  无符号数表示 43</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1010</span> <span class="hljs-number">1011</span>  有符号数表示 -<span class="hljs-number">43</span>  无符号数表示 <span class="hljs-number">171</span><br></code></pre></div></td></tr></table></figure><p>&nbsp;</p><p>如果按照真值的算法来计算，43+(-43) = 0(0000 0000)</p><p>但按正常的原码来计算的话,0010 1011 (43)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">+<span class="hljs-number">1010</span> <span class="hljs-number">1011</span>  (-<span class="hljs-number">43</span>)<br>=<span class="hljs-number">1101</span> <span class="hljs-number">0110</span>  (-<span class="hljs-number">86</span>)<br></code></pre></div></td></tr></table></figure><p>&nbsp;</p><p>可以发现这样计算根本不可能实现我们的需求</p><p>&nbsp;</p><p>而我们的需求是</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"> <span class="hljs-number">0010</span> <span class="hljs-number">1011</span><br>-<span class="hljs-number">0010</span> <span class="hljs-number">1011</span><br>=<span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br></code></pre></div></td></tr></table></figure><p>&nbsp;</p><p>此时就需要我们采用模的原理了，具体可以自己查阅资料</p><p>对于8bit为一个存储单元的的计算机来讲，计算时溢出的数，就自动去除了，所以计算机自动实现了mod(模)2的⑧次方。</p><p>根据模的性质，模-原码绝对值 = 原码的补数</p><p>1,0000 0000 - 0010 1011(-43原码的绝对值) = 1101 0101</p><p>而此时你会发现，所得的补数就是补码</p><p>而此时的计算就是</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">   <span class="hljs-number">0010</span> <span class="hljs-number">1011</span><br>  +<span class="hljs-number">1101</span> <span class="hljs-number">0101</span><br>=<span class="hljs-number">1</span>,<span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br></code></pre></div></td></tr></table></figure><p>此时只有8位存数，那么结果也就是 0000 0000</p><p>&nbsp;</p><p>采用模运算实现减法，可以大大减少硬件的开发成本，底层实现加法和实现减法难度师大的不一样的</p><p>&nbsp;</p><p>至于补码的取法取反加一，根据模的性质</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"> <span class="hljs-number">0010</span> <span class="hljs-number">1011</span>(-<span class="hljs-number">43</span>的绝对值)<br>+<span class="hljs-number">1101</span> <span class="hljs-number">0100</span>(取反)<br>=<span class="hljs-number">1111</span> <span class="hljs-number">1111</span><br></code></pre></div></td></tr></table></figure><p>而1111 1111 + 1 =1,0000 0000</p><p>是不是就可以解释为什么补码是取反加1</p><p>注意在计算补码时 符号位是不变，这里我们是通过模的性质来计算的，所以是-43的绝对值。</p><p>&nbsp;</p><p>所以总的来讲，补码的原意是根据模的性质来的，而补码的意义是为了使硬件不必实现硬件减法仅仅通过加法来实现逻辑上的减法</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;之前也写过一些有关于二进制的文章，但总感觉有一些地方没有真正了解其意义。备考期间，仔细查阅了一些资料，这里记录一下。&quot;&gt;&lt;a href=&quot;#之前也写过一些有关于二进制的文章，但总感觉有一些地方没有真正了解其意义。备考期间，仔细查阅了一些资料，这里记录一下。&quot; cl
      
    
    </summary>
    
    
      <category term="小知识点" scheme="https://fxhstudy.com/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="程序猿" scheme="https://fxhstudy.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF/"/>
    
  </entry>
  
  <entry>
    <title>408-操作系统</title>
    <link href="https://fxhstudy.com/article/c276813a.html"/>
    <id>https://fxhstudy.com/article/c276813a.html</id>
    <published>2023-02-04T09:41:15.000Z</published>
    <updated>2023-02-04T09:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><p>操作系统知识点也比较多，但每年难度不是很大，主要还是理解➕记忆。幕布笔记：<a href='https://www.mubucm.com/doc/8-mMMLGwgG' target='_blank' class='url'>https://www.mubucm.com/doc/8-mMMLGwgG</a></p><p>&nbsp;</p><h3 id='📚概论'>📚概论</h3><figure><table><thead><tr><th>知识点</th></tr></thead><tbody><tr><td>1.CPU从核心态切换到用户态的指令也是特权指令</td></tr><tr><td>2.处于内核态的操作：时钟管理，中断处理，设备驱动，进程管理，存储器管理，设备管理</td></tr><tr><td>3.发生中断或异常时，运行用户态的CPU会立即进入核心态，这是通过<span style='color:red;background:背景颜色;font-size:文字大小;'>硬件</span>完成的。但对中断或者异常的处理，需要操作系统(和驱动程序)完成</td></tr><tr><td>4.访管指令(陷入指令/trap)：发起系统调用，请求操作系统提供服务，是在<span style='color:red;background:背景颜色;font-size:文字大小;'>用户态</span>使用的，所以不可能是特权指令</td></tr><tr><td>5.中断时，<span style='color:red;background:背景颜色;font-size:文字大小;'>硬件</span>自动保存中断程序的断点(即PC和PSW)。通用寄存器是由操作系统保存。硬件找到中断信号对应的中断向量，中断向量指明中断服务程序入口地址(各中断向量统一存放在中断向量表中，该表由操作系统初始化)</td></tr><tr><td>6.用户通过<span style='color:red;background:背景颜色;font-size:文字大小;'>硬件</span>中断机制完成由用户态到核心态的转换，通过访管指令请求。程序异常通过异常处理来进入核心态</td></tr><tr><td>7.大多数计算机系统内核包括四个方面，时钟管理，中断机制，原语和系统控制的数据结构及处理(实际上是系统调用的类的指令(广义指令))。这里注意区分，系统调用，执行一定发生在核心态，而调用可能发生在用户态(也就是用户程序进行了调用)</td></tr><tr><td>8.子程序调用只需保存PC(调用就相当于把子程序的代码替换函数，所以不需要保存状态寄存器)，而中断处理则需要保存PC和PSWR(中断相当于我正在执行，突然去执行其他的程序，是一定需要保存程序的当前状态的)</td></tr><tr><td>9.有关常见的特权指令(或者需要变态的操作)：有关对<span style='color:red;background:背景颜色;font-size:文字大小;'>I/O设备操作</span>的指令；有关访问程序状态的指令；存取<span style='color:red;background:背景颜色;font-size:文字大小;'>特殊寄存器</span>的指令；其他</td></tr><tr><td>10.系统调用发生在用户态,执行在内核态; 外部中断也可以发生在用户态,执行在内核态; 进程切换一定发生并且执行在<span style='color:red;background:背景颜色;font-size:文字大小;'>内核态</span>,这是操作系统的内核程序（属于系统调用执行过程中的事件）; 缺页也是发生在用户态,在内核态处理（确实是大部分发生在用户态下）</td></tr><tr><td>11.系统调用不一定需要专门的硬件，一定需要专门硬件的有地址映射和中断系统</td></tr></tbody></table></figure><p>&nbsp;</p><h3 id='📚操作系统功能-进程管理'>📚操作系统功能-进程管理</h3><figure><table><thead><tr><th>知识点</th></tr></thead><tbody><tr><td>1.PCB申请失败，则进程创建失败；但如果是资源不足，则并不是创建失败，而是处于创建态(结合PCB是进程存在的唯一标准来理解)</td></tr><tr><td>2.用户级线程，用户线程切换不需要转换到内核空间，而内核级线程，用户进程的线程是运行在用户态的，而线程调度和管理是在内核实现的</td></tr><tr><td>3.一般把进程控制用的程序段称为原语，特点是，执行期间不允许中断，是一个不可分割的基本单位。</td></tr><tr><td>4.当被阻塞进程等待的某资源(不包括处理机)可用时，进程将会被唤醒<span style='color:red;background:背景颜色;font-size:文字大小;'>(进程唤醒)，注意‼️进程唤醒是由阻塞态转为就绪态 </span></td></tr><tr><td>5.同一进程中的各个线程拥有各自不同的地址空间（这句话是错的，应该是共享相同的地址空间）</td></tr><tr><td>6.键盘的输入不是多线程的特长(因为一个键盘，等待用户的输入，并且持续输入的速度很慢，一个线程即可)</td></tr><tr><td>7.c语言程序，编写时分为三个段。一般二进制代码和常量存放在正文段，动态分配的存储区在数据堆段，临时变量存放在数据栈段</td></tr><tr><td>8.「进程是多道程序环境中的完整程序」。这种说法是错误的，进程是动态的，而程序是静态的</td></tr><tr><td>9.「每个线程有自己独立的地址空间」这句话是错的，同一进程的各线程间共享进程的地址空间，不同进程拥有各自不同的地址空间</td></tr><tr><td>10.封闭性是指，进程执行的结果只取决于进程本身，不受外界影响。失去封闭性是不同速度下的结果不同</td></tr><tr><td>11.注意⚠️，线程可以独立运行，但是必须要父进程进行启动</td></tr><tr><td>12.在操作系统中，P,V操作是一种<span style='color:red;background:背景颜色;font-size:文字大小;'>低级进程通信原语</span>，它是不能被中断的。而不是系统调用命令</td></tr><tr><td>13.用PV操作实现进程<span style='color:red;background:背景颜色;font-size:文字大小;'>同步</span>，信号量的初值<span style='color:red;background:背景颜色;font-size:文字大小;'>是由用户决定的</span>。若期望的消息未产生，则对应的初值应该设为0；若期望消息已存在，则信号量的初值应该设为一个非0的正整数。例如生产者-消费者中empty为n，full为0，可以很好解释同步中信号量初值的问题。(望重视⚠️了解对PV大题有帮助)</td></tr><tr><td>14.互斥信号量的绝对值（|mutex|）为等待进入的进程数</td></tr><tr><td>15.死锁一定是由<span style='color:red;background:背景颜色;font-size:文字大小;'>两个或者两个以上</span>的进程产生，<span style='color:red;background:背景颜色;font-size:文字大小;'>一个</span>只会导致<span style='color:red;background:背景颜色;font-size:文字大小;'>饥饿</span>。</td></tr><tr><td>16.<span style='color:red;background:背景颜色;font-size:文字大小;'>资源有序分配策略</span>破坏的是循环等待条件；<span style='color:red;background:背景颜色;font-size:文字大小;'>一次性分配策略</span>破坏的是占有请求条件；<span style='color:red;background:背景颜色;font-size:文字大小;'>剥夺资源</span>破坏的是非剥夺条件；银行家算法判断的是<span style='color:red;background:背景颜色;font-size:文字大小;'>是否为不安全状态，不能检测是否发生死锁，死锁避免（硬币- 银避</span>；</td></tr><tr><td>17.注意⚠️⚠️，银行家算法(<span style='color:red;background:背景颜色;font-size:文字大小;'>死锁避免</span>)不会限制用户的申请资源的顺序，而<span style='color:red;background:背景颜色;font-size:文字大小;'>死锁预防</span>访问会限制，这是破坏了循环等待条件。(往年考过的知识点，408就喜欢反复考同一知识点)</td></tr><tr><td>18.模式切换不一定导致进程切换，要<span style='color:red;background:背景颜色;font-size:文字大小;'>进程切换一定要模式切换</span>(模式切换即变态)</td></tr><tr><td>19.在同一进程中，线程的切换不会引起进程切换。但从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。进程切换一定变态</td></tr><tr><td>20.注意内核临界区和普通临界区的区别</td></tr><tr><td>21.同步机制一定要遵循：空闲让进、忙则等待、有限等待、让权等待；而互斥可以不遵循让权等待（皮特森算法）</td></tr><tr><td>22.进程上下文切换时，需要保持的进程状态包括寄存器值、用户和系统内核栈状态</td></tr><tr><td>23.导致进程创建进程的典型事件：<span style='color:red;background:背景颜色;font-size:文字大小;'>用户登录；作业调度；提供服务；应用请求。📌<u><strong>设备分配不会导致创建进程，由内核自动完成。</strong></u></span></td></tr></tbody></table></figure><p>&nbsp;</p><h3 id='📚操作系统功能-内存管理'>📚操作系统功能-内存管理</h3><figure><table><thead><tr><th>知识点</th></tr></thead><tbody><tr><td>1.若采用多级页表机制，为查询方便，各级<span style='color:red;background:背景颜色;font-size:文字大小;'>页表大小不能超过一个页面。（32位系统，32=12+10+10（12是页内寻址，一页4KB，页表项为4B，字节寻址）二级页表；而64位系统=12+10+10+10+10+10+2，六级页表）</span><img src="https://api2.mubu.com/v3/document_image/a038367b-cc02-497a-8251-79e44e8004c3-6205003.jpg" srcset="/img/loading.gif" alt="a038367b-cc02-497a-8251-79e44e8004c3-6205003" style="zoom:50%;" /></td></tr><tr><td>2.<span style='color:red;background:背景颜色;font-size:文字大小;'>PC里面 SP里面存的都是逻辑地址，取完之后再去转换为物理地址访问</span></td></tr><tr><td>3.  <br><img src="https://api2.mubu.com/v3/document_image/27C820582ED04D811663926507.jpg" srcset="/img/loading.gif" alt="img" style="zoom:33%;" /></td></tr><tr><td>4.外部碎片可通过紧凑技术解决，但是需要要花费时间代价比较大</td></tr><tr><td>5.1、页表级数的判断，首先需要知道的是，每一级<span style='color:red;background:背景颜色;font-size:文字大小;'>只能有一张页表</span>(操作系统规定的)，所以我们计算需要多少级页表时，考虑的就是一张页表能够存多少页表项，例如64位操作系统，页面大小是4KB，一个页表项有4B大小，那么一页就能存1K个页表项，(这里的1K=1024)也就是说，这一页如果存下一级页表的信息的话，可以存1K个页表的首地址。而这一级也就是占了64位中的10位，容易算出，64-12=2+10+10+10+10+10，顶级页表存了两位二级页表项（也就是4个二级页表项)，二级页表存了10位三级页表项（也就是1024个三级页表项）。。。这样算下来就是六级。这里的12位表示的是页面大小。</td></tr><tr><td>5.2、注意缺页中断属于内部异常，因为缺页是与当前的指令有关系，所以是可以在指令执行期间响应的。页故障即缺页。<span style='color:red;background:背景颜色;font-size:文字大小;'>但是一定要注意，缺页发生在用户态</span>。之前对这个很困惑，明明内部异常不应该发生在内核态吗？其实这里就是误解了。用户程序发生缺页中断，而用户程序发生在用户态。假如目标内存页在物理内存中没有对应的页帧或者存在但无对应权限，CPU 就无法获取数据，这种情况下CPU就会报告一个缺页错误。由于CPU没有数据就无法进行计算，CPU罢工了用户进程也就出现了缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核处理。(参考文章：<a href='https://blog.csdn.net/universsky2015/article/details/115234769' target='_blank' class='url'>https://blog.csdn.net/universsky2015/article/details/115234769</a>)</td></tr><tr><td>6.页面置换算法中，注意理解缺页中断的次数(即缺页次数)和页面置换的次数。缺页中断次数还包括内存空闲，但页表不在内存调入的次数。</td></tr><tr><td>7.Belady异常只有FIFO算法才会出现，现象是所分配的物理块数增大而页故障不减反增的异常现象。</td></tr><tr><td>8.什么叫抖动(颠簸)？</td></tr><tr><td>9.弄清楚工作集和驻留集的关系</td></tr><tr><td>10.弄清楚页目录和页表的概念(OSp138)</td></tr><tr><td>11.注意理解程序<span style='color:red;background:背景颜色;font-size:文字大小;'>链接</span>时的三种方式(静态链接、装入时链接、运行时链接)、<span style='color:red;background:背景颜色;font-size:文字大小;'>装入</span>内存时(绝对装入、重定位装入、动态运行时装入)，他们各自的特点。理解<span style='color:red;background:背景颜色;font-size:文字大小;'>连续分配</span>的三种方式(单一连续分配、固定分区分配以及动态分区分配)特点</td></tr><tr><td>12.注意⚠️虚拟存储器：作业在运行前，不必全部装入内存，且在运行过程中也不必一直驻留内存。而分页存储管理方式，进程的页表驻留在内存中。</td></tr><tr><td>13.基本分页存储管理方式中，需要将作业全部装入内存，而请求调用则不需要</td></tr><tr><td>14.发生缺页后<img src="https://api2.mubu.com/v3/document_image/063F8FD1355546BB1664351372.jpg" srcset="/img/loading.gif" alt="063F8FD1355546BB1664351372" style="zoom:33%;" /></td></tr><tr><td>15.抖动<img src="https://api2.mubu.com/v3/document_image/72852C55DDDE44FD1664351522.jpg" srcset="/img/loading.gif" alt="72852C55DDDE44FD1664351522" style="zoom:33%;" /></td></tr></tbody></table></figure><p>16.系统调用总汇（零散的总结，不全面）</p><ul>  <li>特权指令与系统调用的区别</li>  <ul>      <li>特权指令是一类只能在核心态下执行的机器指令。而系统调用不是机器指令，它往往以函数调用的形式出现，实现操作系统提供的子功能，它是操作系统与用户的编程接口。在用户程序中可以使用系统调用来获得操作系统服务，在系统调用代码中可以使用特权指令</li>    </ul>  <li>系统调用</li>  <ul>    <li>1.创建新进程</li>    <li>2.进程共享空间是需要用到系统调用的（进程空间一般是独立的）</li>    <li>3.创建线程和终止线程的函数</li>    <li>4.进程调度：一个进程是通过系统调用的方式进入<span style="color:red;background:背景颜色;font-size:文字大小;">阻塞态</span>，此时CPU检测到阻塞，然后进行进程调用。<span style="color:red;background:背景颜色;font-size:文字大小;">而不是</span>进程进行系统调用来发生<span style="color:red;background:背景颜色;font-size:文字大小;">调度</span>的。</li>    <li>5.用户改变当前目录</li>  </ul>  <li>非系统调用</li>      <ul>          <li>1.页面置换：由于缺页而发生的，并不是系统调用而触发的(属于中断，中断与系统调用不同</li>          <li>2.trap指令，这里要理解，trap指令是<span style="color:red;background:背景颜色;font-size:文字大小;">用户程序所依靠的指令，用于发起系统调用，请求操作系统提供服务。理解trap和系统调用的不同，陷阱指令是处理计算机系统意外中断的指令，是由于系统调用引起处理机中断的指令。系统调用是一个大的概念，而trap是一条指令</span>参考博客：https://blog.csdn.net/weixin_51340156/article/details/111735909</li>    </ul>  <li>内核态</li>  <ul>      <li>I/O指令、置中断指令、送程序状态字到程序状态寄存器指令(这里注意一下是送，因为PSW是用户可见寄存器，就是可以读)</li>      <li>加载重定位寄存器和界地址寄存器，只有操作系统可以加载这两个寄存器</li>    </ul></ul><p>17.系统调用与一般过程调用的区别</p><ul>  <li>1.运行状态不同。一般的过程调用,其调用和被调用过程都是用户程序,它们都运行在同一系统状态下;而系统调用的<span style="color:red;background:背景颜色;font-size:文字大小;">调用过程</span>是用户程序,它运行在用户态,其<span style="color:red;background:背景颜色;font-size:文字大小;">被调用过程</span>是系统过程,运行在系统态。</li>  <li>2.进入方式不同。一般过程调用可以直接通过过程调用语句将控制转移到被调用过程;而执行系统调用时,由于调用和被调用过程处于不同系统状态,必须通过访管中断进入。</li>  <li>3.代码层次不同。一般过程调用中的被调用程序是用户级程序,而系统调用是操作系统中的代码程序,是系统级程序。</li></ul><p>&nbsp;</p><h3 id='📚操作系统功能-文件管理'>📚操作系统功能-文件管理</h3><figure><table><thead><tr><th>知识点</th></tr></thead><tbody><tr><td>1.搞清楚什么是目录文件、索引结点、进程打开表、系统打开表、访问控制列表、索引表、文件分配表(FAT)、主文件目录(MFD)、用户文件目录(UFD)</td></tr><tr><td>2.FAT表在系统启动时就会被读入内存，页表也是常驻内存，根目录也是启动时读入内存的</td></tr><tr><td>3.用户改变当前目录是系统调用</td></tr><tr><td>4.文件一旦被打开，内核就不再使用文件名来访问文件，而使用文件描述符(句柄)。所以内核内存中，所存放的进程打开表和系统打开表都是没有文件名的，通过open打开文件返回给用户的是索引，而read系统调用就是通过索引访问进程打开表的。</td></tr><tr><td>5.索引表中存放的是<span style='color:red;background:背景颜色;font-size:文字大小;'>逻辑地址</span></td></tr><tr><td>6.文件目录项即FCB，也就是文件控制块</td></tr><tr><td>7.两个进程各自维护自己的文件描述符，包括读写指针位置。</td></tr><tr><td>8.为减少因查找目录而读磁盘的次数采用<span style='color:red;background:背景颜色;font-size:文字大小;'>索引结点</span>的方法，为减少查找文件的记录而读磁盘的次数采用<span style='color:red;background:背景颜色;font-size:文字大小;'>链接索引</span>的方法。</td></tr><tr><td>9.DOS系统是FAT文件系统，unix系统是UFS(混合索引)</td></tr><tr><td>10.FCB确定文件块首地址，FAT确定块间关系</td></tr><tr><td>11.<span style='color:red;background:背景颜色;font-size:文字大小;'>注意文件物理分配的各种记录物理地址的方式（可能会考）</span></td></tr><tr><td>12.磁盘阵列模式</td></tr><tr><td><img src="https://api2.mubu.com/v3/document_image/4370A029780F4FEA1667026569.jpg" srcset="/img/loading.gif" alt="4370A029780F4FEA1667026569" style="zoom:33%;" /></td></tr><tr><td>13.系统调用表：系统调用表(System Call Table)，是一张由指向实现各种系统调用的内核函数的<span style='color:red;background:背景颜色;font-size:文字大小;'>函数指针</span>组成的表，该表可以基于系统调用编号进行索引，来定位函数地址，完成系统调用。挂载驱动通过修改系统调用表的函数地址可对常用处理函数进行Hook(钩子)函数调用，从而实现对一些核心的系统动作进行过滤和监控的目的。</td></tr><tr><td>14.目录的检索：在顺序检索完成后得到的文件的<span style='color:red;background:背景颜色;font-size:文字大小;'>逻辑地址</span></td></tr><tr><td>15.文件分配方式中：连续分配由FCB记录文件物理地址的起始块号和块长；链接分配中隐式链接由FCB记录文件的起始块号和结束块号，显示链接中FCB中只记录文件的起始块号，FAT表中记录具体信息（408中默认链接分配为隐式链接） ；索引分配中FCB记录的是文件的索引表的块号，然后根据索引表的结构又引申出混合索引的知识点(DOS系统是FAT文件系统，unix系统是UFS(混合索引))</td></tr></tbody></table></figure><p>&nbsp;</p><h3 id='📚操作系统功能-io管理'>📚操作系统功能-I/O管理</h3><figure><table><thead><tr><th>知识点</th></tr></thead><tbody><tr><td>1.硬件机制：就是那种由硬件来控件的中断，用户不能编程更改其机制</td></tr><tr><td>2.I/O系统的层次结构<img src="https://api2.mubu.com/v3/document_image/B95A4114359C4E3B1665038780.jpg" srcset="/img/loading.gif" alt="B95A4114359C4E3B1665038780" style="zoom:33%;" /></td></tr><tr><td>3.缓冲池通常在主存中建立，而输入、输出井则是在磁盘中开辟空间</td></tr><tr><td>4.多道程序设计技术是提高单机资源利用率的关键技术</td></tr><tr><td>5.对独占设备往往采用静态分配方式，共享设备采用动态分配方式</td></tr><tr><td>6.<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>磁盘初始化以及系统启动时的顺序</strong></span></td></tr><tr><td><img src="https://api2.mubu.com/v3/document_image/94C48DBA59D442B91665046396.jpg" srcset="/img/loading.gif" alt="94C48DBA59D442B91665046396" style="zoom:33%;" /><img src="https://api2.mubu.com/v3/document_image/BBBE8875F170489D1669098000.jpg" srcset="/img/loading.gif" alt="BBBE8875F170489D1669098000" style="zoom:33%;" /></td></tr><tr><td>7.<span style='color:red;background:背景颜色;font-size:文字大小;'>光盘</span>、U盘以及磁盘都是可以随机访问，也可以顺序访问</td></tr><tr><td>8.用于设备分配的数据结构<img src="https://api2.mubu.com/v3/document_image/4AEA253D2B5147331665124389.jpg" srcset="/img/loading.gif" alt="4AEA253D2B5147331665124389" style="zoom:33%;" /></td></tr><tr><td>9.注意磁盘调度算法，一定要仔细读题，考试给你的循环扫描有可能是(CSCAN)这里没有加-，我第一次写真题直接以为是扫描算法，导致错了。并且考研中题目没有特殊解释的话，扫描算法和循环扫描算法就是LOOK和C-LOOK</td></tr><tr><td>10.设备独立性软件<img src="https://api2.mubu.com/v3/document_image/D6322476F71245221667030408.jpg" srcset="/img/loading.gif" alt="D6322476F71245221667030408" style="zoom:33%;" /><img src="https://api2.mubu.com/v3/document_image/CA4D66A7DDB34F0E1667030416.jpg" srcset="/img/loading.gif" alt="CA4D66A7DDB34F0E1667030416" style="zoom:33%;" /></td></tr><tr><td>11.理解I/O子系统的层次结构怎么工作的<img src="https://api2.mubu.com/v3/document_image/089988C3E05A45E41667030659.jpg" srcset="/img/loading.gif" alt="089988C3E05A45E41667030659" style="zoom:33%;" /></td></tr></tbody></table></figure><p>&nbsp;</p><h3 id='模糊点'>模糊点</h3><h5 id='1搞清楚各种寄存器'>1.搞清楚各种寄存器</h5><ul>  <li>1.重定位寄存器(基地址寄存器)</li>  <li>2.界地址寄存器(限长寄存器)</li>  <li>3.页表寄存器(PTR)，段表寄存器</li></ul><p>&nbsp;</p><h5 id='2哪些操作需要使用特权指令'>2.哪些操作需要使用特权指令</h5><ul>  <li>1.加载重定位寄存器和界地址寄存器，只有操作系统可以加载这两个寄存器</li>  <li>2.I/O指令、置中断指令、送程序状态字到程序状态寄存器指令</li>  <li>（✓）改变存储器内存保护/管理的寄存器。</li>  <li>（✓）写程序指针。</li>  <li>（x）读取日期时钟。</li>  <li>（✓）设置日期时钟。</li>  <li>（✓）改变处理器的优先级。</li>  <li>（✓）系统重启动。</li>  <li>（✓）关闭中断。</li>  <li>（✓）写指令寄存器。</li></ul><p>&nbsp;</p><h5 id='3硬件完成其他见机组）'>3.硬件完成（其他见机组）</h5><ul>  <li>1.基本分页存储管理中（包括请求分页），地址变换机构中逻辑地址转换为物理地址是由<span style="color:red;background:背景颜色;font-size:文字大小;">硬件</span>完成的</li>  <li>2.发生中断或异常时，运行用户态的CPU会立即进入核心态，这是通过<span style="color:red;background:背景颜色;font-size:文字大小;">硬件</span>完成的。</li>  <li>3.中断时，<span style="color:red;background:背景颜色;font-size:文字大小;">硬件</span>自动保存中断程序的断点(即PC和PSW)。</li>  <li>4.存储保护是由操作系统和硬件合作完成，由硬件实现。如页式存储里，操作系统提供页表，硬件里存放有基址和长度，可以防止越界，整个地址变换都由硬件完成。</li>  <li>5.TLS锁是由硬件实现的（非重点）</li></ul><p>&nbsp;</p><h5 id='4频率的问题'>4.频率的问题</h5><ul>  <li>60Hz意思就是，1/60s执行一次</li></ul><p>&nbsp;</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;

&lt;p&gt;操作系统知识点也比较多，但每年难度不是很大，主要还是理解➕记忆。幕布笔记：&lt;a href=&#39;https://www.mubucm.com/doc/8-mMMLGwgG&#39; target=&#39;_blank&#39; 
      
    
    </summary>
    
    
      <category term="考研" scheme="https://fxhstudy.com/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="考研" scheme="https://fxhstudy.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>408-机组</title>
    <link href="https://fxhstudy.com/article/b38cf06d.html"/>
    <id>https://fxhstudy.com/article/b38cf06d.html</id>
    <published>2023-01-08T05:04:27.000Z</published>
    <updated>2023-01-08T05:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><p>机组难度很大，决定了你的上限，所以如果想考高分的话，需要多花时间去理解”里面”的东西。这里我按照408给的大纲来进行一些总结，下面是我总结的一些笔记，给出幕布链接：</p><p><a href="https://www.mubucm.com/doc/2eLd7orLG-G" target="_blank" rel="noopener" class="LinkCard">计算机组成原理</a></p><h3 id="1、计算机系统概述"><a href="#1、计算机系统概述" class="headerlink" title="1、计算机系统概述"></a>1、计算机系统概述</h3><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>这一章是408必考的知识点，年年考，分值占的比例很大，大题涉及，选择涉及，所以一定要好好掌握</p><h5 id="计算机性能指标☀️"><a href="#计算机性能指标☀️" class="headerlink" title="计算机性能指标☀️"></a>计算机性能指标☀️</h5><p><span style='color:red;background:背景颜色;font-size:文字大小;'>机器字长</span></p><ul>  <li>计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数</li>  <li><span style='color:red;background:背景颜色;font-size:文字大小;'>微处理器的位数就是指的机器字长（如我们常说的64位CPU）</span>，机器字长一般等于<span style='color:red;background:背景颜色;font-size:文字大小;'>内部寄存器</span>的大小，字长越长，数的表示范围越大，计算精度越高。操作系统位数指的是操作系统可寻址的位数</li>    <ul>      <li>注意说法，CPU位数就是机器字长</li>      <img src="https://api2.mubu.com/v3/document_image/9f918425-ad05-4cbf-b881-483057e401a5-6205003.jpg" srcset="/img/loading.gif" alt="9f918425-ad05-4cbf-b881-483057e401a5-6205003" style="zoom:25%;" />      <br/>      <br/>      <li>注意ALU:机器字长就是计算机进行一次整数运算能够处理的二进制位数</li>      <img src="https://api2.mubu.com/v3/document_image/d7b285ff-5883-4e1e-8bd9-106086dd83f6-6205003.jpg" srcset="/img/loading.gif" alt="d7b285ff-5883-4e1e-8bd9-106086dd83f6-6205003" style="zoom:33%;" />      <br/>      <br/>      <img src="https://api2.mubu.com/v3/document_image/df56a450-7fa8-4ea0-946e-f2278dbdddd6-6205003.jpg" srcset="/img/loading.gif" alt="df56a450-7fa8-4ea0-946e-f2278dbdddd6-6205003" style="zoom:33%;" />    </ul>  <li>指令字长（与机器字长对比）</li>    <ul>      <li>一个指令中包含的二进制代码的位数</li>    </ul>  <li>存储字长（与机器字长对比）</li>    <ul>      <li>一个存储单元存储的二进制代码的长度</li>    </ul></ul><p><span style='color:black;background:背景颜色;font-size:文字大小;'>数据通路带宽</span></p><ul>  <li>数据总线一次所能并行传送信息的位数</li></ul><p><span style='color:black;background:背景颜色;font-size:文字大小;'>主存容量</span></p><ul>  <li>主存储器能存储信息的最大容量，通常用字节(B)衡量</li>    <ul>        <li>字数×字长（例 512K×16位）</li>        <li>MAR的位数反映存储单元个数，其反映可寻址范围的最大值</li>        <ul>          <li>MAR16位 表示有2^16=65536个存储单元 （称64K内存） MDR32位 则存储容量 64K×32位</li>        </ul>        <li>n位地址->2^n个存储单元 最大容量= 2^n×存储字长</li>        <li>总容量=存储单元个数×存储字长      bit单位 总容量=存储单元个数×存储字长/8       Byte单位                </li>      </ul></ul><p><span style='color:black;background:背景颜色;font-size:文字大小;'>运算速度</span></p><ul>  <li>吞吐量</li>    <ul>      <li>系统单位时间内处理请求的数量</li>    </ul>  <li>响应时间</li>    <ul>      <li>用户向计算机发送一个请求，到系统做出相应并获得所需结果的等待时间</li>      <ul>        <li>通常包括CPU时间（允许一个程序所花时间）和等待时间（磁盘范围、存储器访问、I/O操作、操作系统开销等）</li>      </ul>    </ul>  <li>CPU时钟周期</li>    <ul>      <li>通常为节拍脉冲或T周期，即主频的倒数，是CPU中最小的时间单位，每个动作至少需要1个时钟周期</li>      <li>有关周期的概念</li>      <ul>        <li>CPU周期就是机器周期</li>        <img src="https://api2.mubu.com/v3/document_image/50ac1884-1502-4066-8e80-c90f99755250-6205003.jpg" srcset="/img/loading.gif" alt="50ac1884-1502-4066-8e80-c90f99755250-6205003" style="zoom:33%;" />        <br/>      </ul>    </ul>  <li>主频（CPU时钟频率）</li>    <ul>      <li>机器内部主时钟的频率</li>      <ul>        <li>CPU时钟周期=1/主频</li>      </ul>      <li>单位 Hz   1Hz表示每秒1次</li>      <li><span style='color:red;background:背景颜色;font-size:文字大小;'>主频越高，完成指令一个步骤所用的时间越短</span></li>    </ul>  <li>CPI</li>    <ul>      <li>执行一条指令所需要的时钟周期数</li>      <li>不同的指令，CPI一般不同，<span style='color:red;background:背景颜色;font-size:文字大小;'>甚至相同的指令，CPI也可能发生变化。</span></li>      <li><span style='color:red;background:背景颜色;font-size:文字大小;'>A、B主机的CPI一样，主频大的一定快？</span>  错，因为还要看指令系统，如果主频大的那个不支持乘法指令，只能通过多步加法来实现，而主频小的那个支持乘法指令</li>    </ul>  <li>CPU执行时间</li>    <ul>      <li>运行一个程序所花费的时间</li>      <li>CPU执行时间=CPU时钟周期数/主频=（指令条数×CPI）/主频</li>    </ul>  <li>MIPS</li>    <ul>      <li>每秒执行多少百万条指令</li>      <ul>        <li>MIPS=指令条数/（执行时间×10^6）=主频/CPI</li>      </ul>    </ul>  <li>MFLOPS</li>    <ul>      <li>每秒执行多少百万次浮点运算</li>      <ul>        <li>MFLOPS=浮点操作次数/（执行时间×10^6）</li>      </ul>    </ul>  <li>GFLOPS</li>    <ul>      <li>GFLOPS=浮点操作次数/（执行时间×10^9）</li>    </ul>  <li>TFLOPS</li>    <ul>      <li>TFLOPS=浮点操作次数/（执行时间×10^12）</li>    </ul>  <li>M、G、T、P、E、Z（单位就是三次方三次方往上加，mg、tp、ez）</li>  <li>1位（b）=1比特（bit） 1字节=8位=8比特</li></ul><h5 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h5><ul>  <li>存储容量=存储字数✖字长</li>  <ul>    <li>存储字数表示存储器的地址空间大小</li>    <li>字长表示一次存取操作的数据量</li>  </ul>  <li>单位成本</li>  <ul>    <li>每位价格=总成本/总容量</li>  </ul>  <li>存储速度</li>  <ul>    <li>数据传输率=数据的宽度/存储周期</li>    <ul>      <li>存取时间（Ta）</li>      <ul>        <li>从启动一次存储器操作到完成该操作经历的时间，分为读出时间和写入时间</li>      </ul>      <li>存取周期（Tm）/读写周期/访问周期</li>      <ul>        <li>存储器进行一次完整的读写操作所需的全部时间 连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔</li>      </ul>      <li>主存带宽（Bm）/数据传输率</li>      <ul>        <li>每秒从主存进入信息的最大数量</li>      </ul>      <li>存取时间不等于存储周期，通常存取周期大于存取时间</li>      <br/>      <img src="https://api2.mubu.com/v3/document_image/bff35f0d-e284-46bb-9d73-9d999f383e92-6205003.jpg" srcset="/img/loading.gif" alt="bff35f0d-e284-46bb-9d73-9d999f383e92-6205003" style="zoom:33%;" />    </ul>  </ul></ul><h5 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h5><ul>  <li>设模块字长等于数据总线宽度，模块存取一个字的存取周期为 T，总线传送周期为 r ，m 称为交叉存取度。</li>  <ul>    <li>为实现流水线方式存取，存储器交叉模块数应大于等于：m＞=T/r</li>    <li>每经 r 时间延迟后启动下一个模块，交叉存储器要求其模块数必须大于或等于m 以保证启动某模块后经过 m×r 的时间后再次启动该模块时，其上次存取操作已经完成（即流水线不间断）</li>    <li>这样连续存取 m 个字所需的时间为</li>    <ul>      <li>t = T + (m-1)r</li>      <li>上式只是取数据，注意如果是<span style='color:red;background:背景颜色;font-size:文字大小;'>总线事务</span>完成，最后还应加上一个r的<span style='color:red;background:背景颜色;font-size:文字大小;'>总线周期去送数据</span></li>    </ul>    <li>顺序方式连续读取 m 个字所需时间为 t2=mT</li>  </ul></ul><h5 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h5><ul>  <li>磁盘的容量</li>  <ul>    <li>一个磁盘所能存储的字节总数</li>    <li>非格式化容量</li>    <ul>      <li>磁记录表面可以利用的磁化单元总数</li>    </ul>    <li>格式化容量</li>    <ul>      <li>按照某种特定的记录格式能存储的信息总量，比非格式化小。（完成划分磁道和扇区，设置文件目录区等操作后的磁盘，当然还有一些备份磁道）</li>    </ul>  </ul>  <li>记录密度</li>    <ul>      <li>所有磁道的信息量一定相等</li>      <br/>      <img src="https://api2.mubu.com/v3/document_image/2959c637-82fd-4ebb-ab55-7e58c3bf252f-6205003.jpg" srcset="/img/loading.gif" alt="2959c637-82fd-4ebb-ab55-7e58c3bf252f-6205003" style="zoom:33%;" />    </ul>  <li><span style='color:red;background:背景颜色;font-size:文字大小;'>平均存取时间</span></li>  <ul>  <img src="https://api2.mubu.com/v3/document_image/d4de9e61-761f-487c-b906-4803f9466dec-6205003.jpg" srcset="/img/loading.gif" alt="img" style="zoom:33%;"/>    <ul>      <li>存取一个扇区的平均延迟时间为旋转半周的时间</li>    </ul>  </ul>  <li>数据传输率</li>  <ul>    <li>磁盘存储器在单位时间内向主机传送数据的字节数</li>    <ul>      <li>D=rN</li>      <ul>        <li>磁盘转数为 r转/秒 每条磁道容量N个字节</li>      </ul>    </ul>  </ul></ul><h5 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h5><ul>  <li>吞吐率【TP】</li>  <ul>    <li>      <img src="https://api2.mubu.com/v3/document_image/f4322795-ded0-4ec9-ae66-134d0cea7212-6205003.jpg" srcset="/img/loading.gif" alt="f4322795-ded0-4ec9-ae66-134d0cea7212-6205003" style="zoom: 50%;" /></li>    <ul>      <li> n 是任务数， Tk是处理完成 n 个任务所用的时间</li>      <li>▲t为时钟周期</li>    </ul>    <li>    <img src="https://api2.mubu.com/v3/document_image/8ad83ef0-dc79-4a21-b107-9b493eef24ff-6205003.jpg" srcset="/img/loading.gif" alt="8ad83ef0-dc79-4a21-b107-9b493eef24ff-6205003" style="zoom:50%;" /></li>  </ul>  <li>加速比</li>  <ul>    <li>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。</li>    <li><img src="https://api2.mubu.com/v3/document_image/85c1d1ba-fcf9-407d-8f77-2a5a531f475f-6205003.jpg" srcset="/img/loading.gif" alt="85c1d1ba-fcf9-407d-8f77-2a5a531f475f-6205003" style="zoom:80%;" /></li>    <li>T0表示不使用流水线时的执行时间，即顺序执行所用的时间  Tk表示使用流水线时的执行时间</li>    <ul>      <li><img src="https://api2.mubu.com/v3/document_image/1fb3acf4-306d-4e6b-a07d-b2bc3dd25558-6205003.jpg" srcset="/img/loading.gif" alt="1fb3acf4-306d-4e6b-a07d-b2bc3dd25558-6205003" style="zoom:80%;" /></li>    </ul>  </ul>  <li>效率</li>    <ul>      <li><img src="https://api2.mubu.com/v3/document_image/a2cd26a3-01b2-4cd3-8e02-4532c1e610e7-6205003.jpg" srcset="/img/loading.gif" alt="a2cd26a3-01b2-4cd3-8e02-4532c1e610e7-6205003" style="zoom:50%;" /></li>    </ul></ul><h5 id="周期概念"><a href="#周期概念" class="headerlink" title="周期概念"></a>周期概念</h5><ul>  <li><img src="https://api2.mubu.com/v3/document_image/6829523853BB44711663136668.jpg" srcset="/img/loading.gif" alt="6829523853BB44711663136668" style="zoom:50%;" /></li></ul><h5 id="字长概念"><a href="#字长概念" class="headerlink" title="字长概念"></a>字长概念</h5><ul>  <li>机器字长：机器字长就是计算机进行一次整数运算能够处理的二进制位数</li>  <li>指令字长：一个指令中包含的二进制代码的位数</li>  <li>存储字长：一个存储单元存储的二进制代码的长度</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul>  <li>1s🟰1000ms🟰1000,000微秒🟰1,000,000,000纳秒</li>  <li>1GHz🟰1,000MHz🟰1,000,000KHz🟰1,000,000,000Hz</li>  <li>1/1KHz🟰1ms</li></ul><h3 id="2、数据的表示和运算"><a href="#2、数据的表示和运算" class="headerlink" title="2、数据的表示和运算"></a>2、数据的表示和运算</h3><p>第二章的知识点难理解，涉及到数据的一些表示，这里不介绍数据的具体框架知识点，只介绍一些容易忽视的地方</p><table><thead><tr><th>小知识点</th></tr></thead><tbody><tr><td>1、对于位数相同的定点数和浮点数，可表示的数据<span style='color:red;background:背景颜色;font-size:文字大小;'>个数</span>应该是一样多的。编码位数一定，编码出来的数据个数就是一定的。</td></tr><tr><td>2、补码的一位乘法和原码的除法，其中补码乘法需要做n+1次加，而原码的除法根据第n次余数是否与被除数同号，非同号需要n+1次加</td></tr><tr><td>3、正数原码、补码以及反码是一样的，负数的补码等于反码加一，负数的反码等于原码除符号位取反</td></tr><tr><td>4、C语言中类型转化方向：char—&gt;int—&gt;long—&gt;double</td></tr><tr><td>5、<span style='color:red;background:背景颜色;font-size:文字大小;'>基数</span>越大<span style='color:red;background:背景颜色;font-size:文字大小;'>精度</span>越低，<span style='color:red;background:背景颜色;font-size:文字大小;'>进制</span>越大<span style='color:red;background:背景颜色;font-size:文字大小;'>精度</span>越高。(比如某些10进制小数不能用2进制表示，但是所有二进制小数都可以用10进制表示，这样就很容易理解10进制精度更高)</td></tr><tr><td>6.原码表示时，正数规格化形式为0.1xxx，负数格式化形式为1.1xxx</td></tr><tr><td>7.注意⚠️IEEE745一定要记住，阶码计算是通过二进制算出来的值E，再减127，而不是128，即1001 0011算出来的阶码应该是20(128+16+2+1-127=20)。其中E的取值为1～254，所以阶码单位为-126～127</td></tr><tr><td>8.采用规格化的浮点数最主要是为了增加数据的表示精度。</td></tr><tr><td>9.对于无符号整数乘法，若乘积高n位全为0，即使第n位全为1也正好是2^32-1，不溢出，否则溢出</td></tr><tr><td><span style='color:red;background:背景颜色;font-size:文字大小;'>10.CF=count异或sub     count为最高位的进位，sub为加减控制信号，加法0，减法1</span></td></tr><tr><td><span style='color:red;background:背景颜色;font-size:文字大小;'>11.OF=次高进位异或最高进位</span></td></tr><tr><td>12.乘法溢出判断</td></tr><tr><td><img src="https://api2.mubu.com/v3/document_image/17C6092D8A5143281665297368.jpg" srcset="/img/loading.gif" alt="17C6092D8A5143281665297368" style="zoom: 25%;" /></td></tr></tbody></table><h3 id="3、存储系统"><a href="#3、存储系统" class="headerlink" title="3、存储系统"></a>3、存储系统</h3><table><thead><tr><th>小知识点</th></tr></thead><tbody><tr><td>1.主存和cache之间的数据调动是由<span style='color:red;background:背景颜色;font-size:文字大小;'>硬件</span>自动完成的，对所有程序员均是透明的；而主存和辅存之间的数据调动，则是由<span style='color:red;background:背景颜色;font-size:文字大小;'>硬件和操作系统</span>共同完成的，对应用程序员是透明的(CPU与Cache之间的数据交换是以字为单位，Cache与主存是以块为单位)</td></tr><tr><td>2.DRAM的刷新是由<span style='color:red;background:背景颜色;font-size:文字大小;'>硬件</span>自动完成的</td></tr><tr><td>3.高速缓冲存储器是从系统结构上进行改造，使得速度变快</td></tr><tr><td>4.虚拟存储管理系统的基础是程序访问的局部性原理， 此理论的基本含义是 在程序的执行过程中， 程序对主存的访问是不均匀的</td></tr><tr><td>5.虚拟存储器采用的是全相联映射，因为关键是提高命中率，所以还是采用的是回写法</td></tr></tbody></table><h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>这一块得区分一下，细节的地方比较多，并且OS也涉及到了</p><h5 id="映射方式"><a href="#映射方式" class="headerlink" title="映射方式"></a>映射方式</h5><p>1.直接映射</p><ul>  <li>Cache行的字段是：标记➕数据（这里的标记是，主存块号➖Cache总行数所占的位数）</li>  <li>直接映射的地址结构是：标记➕Cache行号➕块内地址（可以看出来，其实就是主存的访问地址，只是先通过这个地址去Cache中找。标记➕Cache行号对应的就是主存块的地址，再加块内地址，找到具体位置）</li></ul><p>2.全相联映射</p><ul>  <li>Cache行的字段是：标记➕数据（这里的标记是就主存块号，所以全相联映射慢，需要和相联存储器一起用）</li>  <li>地址结构：标记➕块内地址（因为是随机的，所以标记就是主存块号）</li></ul><p>3.组相联映射</p><ul>  <li>Cache行的字段是：标记➕数据（这里的标记是，主存块号位数➖Cache总组数所占的位数(可以和直接映射对比一下)，比如主存块号位数是11，Cache有8组，也就是占3位，那么标记占了11 - 3 = 8位）</li>  <li>地址结构：标记➕组号➕块内地址</li></ul><p>其中直接映射和组相联映射都是先查找行号/组号找到对应的Cache行/组，然后再和标记进行对比，再检查有效位。</p><h5 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h5><p>直接上图</p><img src="https://api2.mubu.com/v3/document_image/60A66287F4BA487D1666854235.jpg" srcset="/img/loading.gif" alt="60A66287F4BA487D1666854235" style="zoom: 33%;" /><table><thead><tr><th>表格</th></tr></thead><tbody><tr><td>1.有效位：为说明Cache行中的信息是否有效，每一个Cache行需要一个有效位</td></tr><tr><td>2.LRU位：替换算法如果采用LRU(最近最少使用算法)，位数与Cache组的大小有关系，需要注意2路占一位LRU位，4路占两位LRU位；Clock算法还有访问位(不过用于操作系统)</td></tr><tr><td>3.修改位：回写法需要注意增加一个修改位(脏位)</td></tr><tr><td>4.失页率的计算要包括全部缺页</td></tr><tr><td>5.Cache缺失由<span style='color:red;background:背景颜色;font-size:文字大小;'>CPU硬件</span>实现，缺页处理由<span style='color:red;background:背景颜色;font-size:文字大小;'>软件</span>来完成</td></tr><tr><td><img src="https://api2.mubu.com/v3/document_image/FB28CC3C9F6E43B01662018650.jpg" srcset="/img/loading.gif" alt="FB28CC3C9F6E43B01662018650" style="zoom: 50%;" /></td></tr><tr><td>6.Cache对所有程序员都透明，而虚存对应用程序员透明，系统程序员不透明。</td></tr><tr><td>7.注意⚠️TLB路数并不能决定虚拟地址中标记要留多少位给组，而是根据TLB组数来决定标记留几位。</td></tr><tr><td></td></tr></tbody></table><h5 id="Cache总位数的计算"><a href="#Cache总位数的计算" class="headerlink" title="Cache总位数的计算"></a>Cache总位数的计算</h5><p>注意⚠️组相联和直接映射的区别，组相联和直接映射在计算Cache位数算的都是Cache总行数，组相联计算的不是总组数！</p><p>例题</p><img src="https://api2.mubu.com/v3/document_image/CE2BD4815FF142F31662278712.jpg" srcset="/img/loading.gif" alt="CE2BD4815FF142F31662278712" style="zoom: 25%;" /><p>答案</p><img src="https://api2.mubu.com/v3/document_image/EC5D16CF846E4BEF1662278749.jpg" srcset="/img/loading.gif" alt="EC5D16CF846E4BEF1662278749" style="zoom:25%;" /><h4 id="芯片引脚"><a href="#芯片引脚" class="headerlink" title="芯片引脚"></a>芯片引脚</h4><p>芯片引脚408考得不深，大概就是SRAM和DRAM最少数目之类的，最多往年没有考过，所以记住即可。</p><h5 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h5><p>SRAM最小数考虑CS(片选信号线)➕读写信号线</p><p>例题</p><img src="https://api2.mubu.com/v3/document_image/1EA9F1C21B604A5E1662101999.jpg" srcset="/img/loading.gif" alt="1EA9F1C21B604A5E1662101999" style="zoom:33%;" /><p>答案</p><h5 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a><img src="https://api2.mubu.com/v3/document_image/C5ADC248958645421662102126.jpg" srcset="/img/loading.gif" alt="C5ADC248958645421662102126" style="zoom:33%;" />DRAM</h5><h5 id="DRAM-1"><a href="#DRAM-1" class="headerlink" title="DRAM"></a>DRAM</h5><p>DRAM最小数考虑读写信号线➕行通选和列通选信号线(一共两根)，并且<span style='color:red;background:背景颜色;font-size:文字大小;'>DRAM采用地址复用，地址线减少一半</span></p><p>例题</p><img src="https://api2.mubu.com/v3/document_image/DA8A8986315E46121662102029.jpg" srcset="/img/loading.gif" alt="DA8A8986315E46121662102029" style="zoom:33%;" /><p>答案</p><img src="https://api2.mubu.com/v3/document_image/5542342F39EB4FDE1662102235.jpg" srcset="/img/loading.gif" alt="5542342F39EB4FDE1662102235" style="zoom:33%;" /><h3 id="4、指令系统"><a href="#4、指令系统" class="headerlink" title="4、指令系统"></a>4、指令系统</h3><p>无，指令系统因为本科阶段打比赛汇编学得比较多，所以当时这一部分学起来不是很困难。</p><h3 id="5、中央处理器"><a href="#5、中央处理器" class="headerlink" title="5、中央处理器"></a>5、中央处理器</h3><p>这章知识点很多，容易漏的知识点也比较多，所以需要多总结多思考</p><table><thead><tr><th>小知识点</th></tr></thead><tbody><tr><td>1.中断响应是CPU在每条指令执行结束前检查的，如果有，就进入中断周期，并且保存断点</td></tr><tr><td>2.理解什么是超标量流水线技术，超流水线技术</td></tr><tr><td>3.转移指令，PC并不总是修改为转移指令的目标地址，在转移指令时，需判别是否转移成功，成功则是目标地址，失败则是PC➕1</td></tr><tr><td>4.间址周期结束时，MDR中存放是的操作数的地址，而具体的操作数，需要到执行周期去取</td></tr><tr><td>5.按字节编制的时候需要注意，若题目又说按字边界对齐存放，此时MAR(或者有关的位数)就是主存空间/(字长/8)——16年统考选</td></tr><tr><td>6.指令字长一般取字节或者存储字长的整数倍，而不一定都和存储字长一样大</td></tr><tr><td>7.取指操作是自动进行的，控制器不需要得到相应的指令</td></tr><tr><td>8.空操作指令会导致PC增加，而不是寄存器都不变。并且空指令会进行访存，自己想想为什么？——-因为空指令，会在取指阶段去内存取这条空指令，所以会访存🤣</td></tr><tr><td>9.计算机基本上可以分为两大类：控制部件和执行部件。控制部件主要就是控制器，执行部件包括运算器，存储器，外围设备</td></tr><tr><td>10.CPU检测到异常事件后所做的处理和检测到中断请求后所做的处理完全相同（❌）                                          <span style='color:red;background:背景颜色;font-size:文字大小;'>应该是基本相同的，而不是完全相同的</span></td></tr><tr><td>11.超线程技术是一个在CPU中，提供两套线程处理单元，让单个处理机实现线程级并行。采用超线程技术可以同时执行两个线程，但当两个线程同时需要某个资源的时候，其中一个线程必须挂起</td></tr><tr><td>12.中断向量是地址，异常或中断处理程序的<span style='color:red;background:背景颜色;font-size:文字大小;'>首地址</span>称为中断向量。而中断向量地址，指的是存放在中断向量表中的中断向量的地址</td></tr><tr><td>13.中断处理结束是<span style='color:red;background:背景颜色;font-size:文字大小;'>可能</span>引起进程调度程序执行。这是因为在时间轮转调度算法中，中断处理结束后，系统会检测当前进程的时间片是否用完，用完将其设为就绪态</td></tr><tr><td>14.在进程处于临界区时不能进行处理机调度。这种说法是不对的，处于系统临界区以及IO这种不能进行处理机调度。一些不破坏临界资源使用规则的可以调度</td></tr><tr><td>15.时间片轮转是绝对可抢占的，优先级有分抢占式和非抢占式</td></tr><tr><td>16.可重入代码(Reentry code)也叫<a href="https://baike.baidu.com/item/纯代码/5669644?fromModule=lemma_inlink" target="_blank" rel="noopener">纯代码</a>(Pure code)是一种允许多个进程同时访问的代码。</td></tr><tr><td>17.异步总线一次通信往往会交换多位而非一位数据，DMA请求是每次传输一块数据(容易模糊，记混)，<span style='color:red;background:背景颜色;font-size:文字大小;'>但是这里要注意，题目可能要求的是采取窃取周期的方式进行DMA传输，这时DMA每次传输的是一个字的数据（真题考过两次DMA窃取周期方式）</span></td></tr><tr><td>18.什么叫断定方式？(P232)；什么是数据旁路技术？</td></tr><tr><td>19.注意<span style='color:red;background:背景颜色;font-size:文字大小;'>访存</span>阶段是将结果写入<span style='color:red;background:背景颜色;font-size:文字大小;'>存储器</span>，而<span style='color:red;background:背景颜色;font-size:文字大小;'>写回</span>阶段是将结果写入<span style='color:red;background:背景颜色;font-size:文字大小;'>寄存器</span></td></tr><tr><td>20.一个<span style='color:red;background:背景颜色;font-size:文字大小;'>寄存器</span>机器指令(即指令)对应一个<span style='color:red;background:背景颜色;font-size:文字大小;'>微程序</span>，一个<span style='color:red;background:背景颜色;font-size:文字大小;'>微程序</span>对应一段<span style='color:red;background:背景颜色;font-size:文字大小;'>微指令</span>，一个<span style='color:red;background:背景颜色;font-size:文字大小;'>微指令</span>对应若干<span style='color:red;background:背景颜色;font-size:文字大小;'>微命令</span>，一个<span style='color:red;background:背景颜色;font-size:文字大小;'>微命令</span>也就是一个<span style='color:red;background:背景颜色;font-size:文字大小;'>微操作</span></td></tr><tr><td>21.一个<span style='color:red;background:背景颜色;font-size:文字大小;'>指令周期</span>对应若干<span style='color:red;background:背景颜色;font-size:文字大小;'>机器周期</span>，一个<span style='color:red;background:背景颜色;font-size:文字大小;'>机器周期</span>对应若干<span style='color:red;background:背景颜色;font-size:文字大小;'>时钟周期</span>(时钟周期倒数也就是频率)，一个<span style='color:red;background:背景颜色;font-size:文字大小;'>指令周期</span>对应至少一个<span style='color:red;background:背景颜色;font-size:文字大小;'>总线周期(思考原因，这是因为一个指令周期至少需要访存一次，即取指令)，一个指令周期对应若干存取周期</span></td></tr><tr><td>注意理清思路<img src="https://api2.mubu.com/v3/document_image/6135F83379C84D881668070375.jpg" srcset="/img/loading.gif" alt="6135F83379C84D881668070375" style="zoom: 50%;" /></td></tr><tr><td>22.注意理解多核处理器、多处理器、硬件多线程技术（多线程技术）</td></tr></tbody></table><h3 id="6、总线"><a href="#6、总线" class="headerlink" title="6、总线"></a>6、总线</h3><p>无，408总线这一块考得知识点很少，也不会考很深。</p><h3 id="7、输入输出系统"><a href="#7、输入输出系统" class="headerlink" title="7、输入输出系统"></a>7、输入输出系统</h3><table><thead><tr><th>小知识点</th></tr></thead><tbody><tr><td>1.什么是中断请求标志寄存器，屏蔽字寄存器（中断屏蔽触发器）、中断允许触发器</td></tr><tr><td><img src="https://api2.mubu.com/v3/document_image/FE8B321C01F748F41668242293.jpg" srcset="/img/loading.gif" alt="FE8B321C01F748F41668242293" style="zoom:33%;" /><img src="https://api2.mubu.com/v3/document_image/A01869EF199A42EC1668242300.jpg" srcset="/img/loading.gif" alt="A01869EF199A42EC1668242300" style="zoom:33%;" /></td></tr><tr><td>2.程序查询方式，程序中断方式每次都是读一个字，而DMA读写可以以单字节(或字)为基本单位，也可以以数据块为基本单位</td></tr><tr><td>3.对中断请求的响应只能发生在每条指令<span style='color:red;background:背景颜色;font-size:文字大小;'>执行完毕</span>时(即执行周期后)，而DMA请求的响应可以发生在每个<span style='color:red;background:背景颜色;font-size:文字大小;'>机器周期结束</span>(取指周期、间址周期、执行周期)</td></tr><tr><td>4.DMA除了预处理和后处理阶段，数据传输阶段是不需要CPU控制的，是<span style='color:red;background:背景颜色;font-size:文字大小;'>完全</span>由DMA控制器(<span style='color:red;background:背景颜色;font-size:文字大小;'>硬件</span>)控制的</td></tr><tr><td>5.DMA包括主存地址的确定、传送数据的计数，以及发出中断请求信号都是自动的。</td></tr><tr><td>6.DMA开始前通过程序进行预处理，结束后通过中断方式进行后处理，都需要CPU参与</td></tr><tr><td>7.程序中断方式中，由硬件完成的是，保存断点(PSW和PC)以及中断服务程序寻址(将寻址后的地址存入PC)</td></tr><tr><td>8.IO端口在统一编址的方式下，区分存储单元和I/O设备是靠<span style='color:red;background:背景颜色;font-size:文字大小;'>地址码区分的</span></td></tr><tr><td>9.IO指令只能在操作系统内核使用，是一种特权指令</td></tr><tr><td>10.注意⚠️：接口中控制线主要用于传送读写信号、一些仲裁信号以及握手信号。至于和对外设管理的控制是由I/O控制逻辑来完成的，所以I/O接口的指令字，状态字以及中断类型号都是在数据线上传输的</td></tr><tr><td>11.IO接口中，CPU可以直接访问的寄存器是I/O端口，包括数据端口、控制端口以及状态端口</td></tr><tr><td>12.通用寄存器和I/O端口之间的数据传送通常由I/O指令实现的，而I/O端口和I/O设备之间的数据传送是由<span style='color:red;background:背景颜色;font-size:文字大小;'>指令字</span>实现的。</td></tr><tr><td>13.中断返回指令和转移指令不一样，转移指令只需要修改PC的值，而中断返回指令不仅需要修改PC的值，而且需要恢复CPU中断前的环境(通用寄存器、PSW…)</td></tr><tr><td>14.DMA传送过程中，<span style='color:red;background:背景颜色;font-size:文字大小;'>设备</span>设备发出DMA请求，而DMA控制器向CPU发出<span style='color:red;background:背景颜色;font-size:文字大小;'>总线</span>请求</td></tr><tr><td>15.注意⚠️，用户的输入输出，一定是<span style='color:red;background:背景颜色;font-size:文字大小;'>访管中断</span>，不要学了IO以后，认为输入输出是IO中断</td></tr><tr><td>16.在中断响应周期中，由<span style='color:red;background:背景颜色;font-size:文字大小;'>中断隐指令</span>将允许中断触发器置0</td></tr><tr><td>17.DMA要等存取周期(机器周期)结束时才可以进行周期窃取，而不是指令周期、总线周期</td></tr><tr><td>18.<span style='color:red;background:背景颜色;font-size:文字大小;'>存取周期</span>是对于主存来说的，是主存的性能指标。存取周期是对内存进行一次读/写操作从得到地址到完成读/写操作以及下一次读/写操作开始前的总时间；<span style='color:red;background:背景颜色;font-size:文字大小;'>总线周期</span>是对于总线来说的，是总线的性能指标。总线周期又称为总线的传输周期，包括申请阶段，寻址阶段，传输阶段和结束阶段，一般来说，总线周期是由多个总线时钟周期构成的。</td></tr><tr><td>19.DMA的优先级比外中断(非屏蔽中断、可屏蔽中断)要高，这里的非屏蔽中断不包括故障，如果包括故障的话，非屏蔽中断&gt;内部异常&gt;可屏蔽中断</td></tr><tr><td>20.单位时间内I/O请求数量比中断处理的多，数据就会丢失(大题需要注意)</td></tr></tbody></table><h3 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h3><h5 id="1-各个部件由什么构成"><a href="#1-各个部件由什么构成" class="headerlink" title="1.各个部件由什么构成"></a>1.各个部件由什么构成</h5><ul>  <li>1.控制存储器CM—ROM</li>  <li>2.Cache—SRAM</li>  <li>3.主存—DRAM、ROM</li></ul><h5 id="2-由硬件进行的操作"><a href="#2-由硬件进行的操作" class="headerlink" title="2.由硬件进行的操作"></a>2.由硬件进行的操作</h5><ul>  <li>1.DMA数据传输阶段</li>  <li>2.程序中断方式中断点保存(即中断隐指令)以及中断程序寻址</li>  <li>3.主存和cache之间的数据调动是由<span style='color:red;background:背景颜色;font-size:文字大小;'>硬件</span>自动完成的，主存和辅存之间的数据调动，则是由<span style='color:red;background:背景颜色;font-size:文字大小;'>硬件和操作系统</span>共同完成的。</li>  <li>4.微程序控制器中微指令设计中，第一条微指令地址（用专门的硬件记录取指周期微程序首地址）和 中断周期微程序的首地址 都是由硬件产生</li>  <li>5.DRAM的刷新是由硬件自动完成的</li></ul><h5 id="3-用户可见寄存器-不可见寄存器"><a href="#3-用户可见寄存器-不可见寄存器" class="headerlink" title="3.用户可见寄存器/不可见寄存器"></a>3.用户可见寄存器/不可见寄存器</h5><p>在CPU中，IR，MAR和MDR对各类程序员都是透明的，但通用寄存器组、程序状态寄存器对程序员是可见的。</p><p>用户可见的寄存器</p><ul>  <li>通用寄存器组</li>  <li>程序状态字寄存器【PSW】</li>  <li>程序计数器【PC】</li>  <li>累加寄存器【ACC】</li>  <li>中断字寄存器</li></ul><p>用户不可见的寄存器</p><ul>  <li>指令寄存器【IR】</li>  <li>暂存寄存器【DR】</li>  <li>存储器地址寄存器【MAR】</li>  <li>存储器数据寄存器【MDR】</li>  <li>主存和cache之间的数据调动是由<span style='color:red;background:背景颜色;font-size:文字大小;'>硬件</span>自动完成的，，对所有程序员均是透明的；主存和辅存之间的数据调动，则是由<span style='color:red;background:背景颜色;font-size:文字大小;'>硬件和操作系统</span>共同完成的，对应用程序员是透明的。</li>  <li>指令缓冲器、移位器、乘法器、先行进位链</li>  <li>等等，除去上面的用户可见寄存器，其他的基本上都不可见，比如移位寄存。。。</li></ul></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;


&lt;p&gt;机组难度很大，决定了你的上限，所以如果想考高分的话，需要多花时间去理解”里面”的东西。这里我按照408给的大纲来进行一些总结，下面是我总结的一些笔记，给出幕布链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="考研" scheme="https://fxhstudy.com/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="考研" scheme="https://fxhstudy.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>408-数据结构</title>
    <link href="https://fxhstudy.com/article/15ab325d.html"/>
    <id>https://fxhstudy.com/article/15ab325d.html</id>
    <published>2023-01-08T05:04:19.000Z</published>
    <updated>2023-01-08T05:24:16.000Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><p>以下是我在备考期间的一些笔记，算是一些小总结吧，如果你408准备得还可以了，可以看看下面的总结，我认为可能会给你一些启发的。这篇是关于数据结构的一些知识点，但是由于数据结构的总体难度算是偏小的了，所以备考过程中的笔记算是比较少的了。幕布笔记：</p><p><a href="https://www.mubucm.com/doc/6_Zq20fDK2G" target="_blank" rel="noopener" class="LinkCard">数据结构</a></p><h3 id="1-散列表计算ASL"><a href="#1-散列表计算ASL" class="headerlink" title="1.散列表计算ASL"></a>1.散列表计算ASL</h3><p>一般线性表和顺序线性表在查找成功的情况下平均查找长度是一样的，失败是不一样的(具体思考)</p><p>注意散列表的ASL计算，成功时查找除去的是个数，失败是除去散列函数中的质数，而不是散列表的长度</p><p>考点一：散列表查找失败+线性探查</p><p><img src="https://api2.mubu.com/v3/document_image/6DAB44A6194B4D8A1665730552.jpg" srcset="/img/loading.gif" alt="img"></p><p>这里注意失败时，求平均长度除以的是7，而插入时，因为20和6会有冲突，此时20的计算是H=(H(key)+d)%m，这里的m取的是散列表的长度<span style='color:red;background:背景颜色;font-size:文字大小;'>（一定要理解为什么要%m，不要不知道就跳过去了‼️，这里是选项探测法的要点）</span></p><p>考点二：查找失败时，分母注意是给定散列函数的质数</p><p><img src="https://api2.mubu.com/v3/document_image/E0F1C48CD43840991665731362.jpg" srcset="/img/loading.gif" alt="E0F1C48CD43840991665731362"></p><p>考点三：注意理解查找失败的情况，不将质数之外的数算进去，也就是计算0～6失败的情况。而查找成功是按照关键字个数来计算的，需要将题目中的七个都计算进去(基本上理解这个，ALS也就没有太大的问题了)</p><img src="https://api2.mubu.com/v3/document_image/F0E52FE293F642081665731954.jpg" srcset="/img/loading.gif" alt="F0E52FE293F642081665731954" style="zoom:80%;" /><p>考点四：装填因子是由关键字长度/表长，有时候会给你装填因子和关键字长度，让你计算表长或者构造散列函数，注意散列函数的是取质数的</p><h3 id="2-树和图的度的区别"><a href="#2-树和图的度的区别" class="headerlink" title="2.树和图的度的区别"></a>2.树和图的度的区别</h3><p>1、一定要注意两者的度的定义是不一样的，树的度是指节点的个数，无向图的度是边数✖️2，如果将树转化为图的话，那么树的度就是有向图的出度。</p><p>2、这里也要注意最小生成树的度/边的问题，最小生成树虽然有“树”在里面，但是本质上是图（极小连通图），所以最小生成树度的算法应该是图的度的算法</p><h3 id="3-平衡二叉树"><a href="#3-平衡二叉树" class="headerlink" title="3.平衡二叉树"></a>3.平衡二叉树</h3><p>1、平衡二叉树，深度为h，<span style='color:red;background:背景颜色;font-size:文字大小;'>最少</span>结点数为Nh=Nh-1+Nh-2+1，N0=0，N1=1，N2=2</p><h3 id="4-时间复杂度"><a href="#4-时间复杂度" class="headerlink" title="4.时间复杂度"></a>4.时间复杂度</h3><p>时间复杂度在408中考得频率挺高，去年考得一题难度很大。这种题目就是注意频率了，下图类型②就是去年考的知识点，时间复杂度为O(N)<img src="https://api2.mubu.com/v3/document_image/C7ABBCA5E9F843D01669357818.jpg" srcset="/img/loading.gif" alt="C7ABBCA5E9F843D01669357818"></p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;

&lt;p&gt;以下是我在备考期间的一些笔记，算是一些小总结吧，如果你408准备得还可以了，可以看看下面的总结，我认为可能会给你一些启发的。这篇是关于数据结构的一些知识点，但是由于数据结构的总体难度算是偏小的了，所以备
      
    
    </summary>
    
    
      <category term="考研" scheme="https://fxhstudy.com/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="考研" scheme="https://fxhstudy.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>408考研</title>
    <link href="https://fxhstudy.com/article/2b671a33.html"/>
    <id>https://fxhstudy.com/article/2b671a33.html</id>
    <published>2023-01-08T04:56:42.000Z</published>
    <updated>2023-01-08T05:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><p>很久没有更新博客了，是准备复试结束后再更新博客的，但确实太久没有更新了，所以准备花点时间记录一下408考研的一些知识点。</p><p>408专业课分四门：数据结构、计算机组成原理、操作系统和计算机网络</p><p>加起来一共150分，但这150分可以说是工科统考中最难拿的150分，可以说408是工科考研的天花板了，难度很大。<br>专业课考研分为自命题和统考，自命题就是学校自己出的卷子，统考就是由教育部出的卷子。自命题的好处是从开始准备到复试你竞争的就是那一批人，因为自命题中途换学校的毕竟占少数，所以你的竞争对手是一定的。而坏处是自命题不透明，出什么题目是由报考学校相应院部自己决定的，这就会导致本校的学生考研的优势会大于非本校学生，有的学校会故意出得偏，这就会导致考生复习到的知识点没有考到。自命题的学校有的会故意压低分数，就是将专业课出得很难，普遍分数就下来了，最后还是靠数学和英语，调剂也不好调，安大和南理工就是这样，只是南理工今年改408了。其次，有的自命题学校可参考往年的试题很少，这也是之前我同学遇到的情况，他报考的学校专业课可参考的试题只有三到五年，导致你不知道今年出得的题型往年有没有出过，这会在备考阶段很难受。最后，存在一些学校中途会换考研科目，比如安师大今年计算机就是九月份改考了408，导致之前准备安师大自命题基本上都放弃了，九月份开始准备408根本不够，今年东南大学也是，自命题计算机也加了一门，通知得很晚，导致很多学生被迫换学校。</p><p>而408的缺点很明显是难度很大，非常大，报考408也就意味着你需要复习4门课，很多很多，如果你底子不好，千万不要选择408，我室友就是很好的例子，408很早就开始学了，但最后考得都不好，这也是408唯一缺点。408好处非常多，就今年一年改考408的学校就二三十所，明年只会更多，也就意味着，如果你在十月份、十一月份觉得准备的不好，你可以随时随地换学校，上到C9、985，下到双非二本，都有考408的学校，而自命题这种情况基本上不可能。并且408往年试题可参考很多，它是从09年开始的，到22年已经有十几套可以拿来练习，大致考得题型也都固定了，很透明。其次因为408难度很大，会导致一般211的分数不会很高，因为408上一百的就一已经算是比较厉害的那一批了，所以分数相对较低。最后，我认为也是最重要一点，只要你认真学了408，基本知识点都弄清楚了，以后不管找工作还是继续深造，你都会发现你底子很好，这也是很多人选择408的原因。反正除了难，基本上没有什么缺点，但也确实太难了。</p><p>如果你想准备考408的话，需要早作准备，因为知识点很多，本身学理科的不怎么偏向记忆，所以更要多花时间去准备。这里还得说一下，如果你机组和代码不行，那你考408注定拿不到高分，这里代码要求不严格，就是一些数据结构的实现以及操作可以实现，基本上数据结构的代码题就差不多了。408机组45分，数据结构45分，如果你机组不认真学，基本上到顶也就是及格分左右。</p><p>后面闲下来了的话，会出一篇考研的一些注意点，可能详细一点要到复试之后(还不确定能不能进复试：(</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;

&lt;p&gt;很久没有更新博客了，是准备复试结束后再更新博客的，但确实太久没有更新了，所以准备花点时间记录一下408考研的一些知识点。&lt;/p&gt;
&lt;p&gt;408专业课分四门：数据结构、计算机组成原理、操作系统和计算机网络
      
    
    </summary>
    
    
      <category term="考研" scheme="https://fxhstudy.com/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="考研" scheme="https://fxhstudy.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>算法-分而治之第一篇</title>
    <link href="https://fxhstudy.com/article/ba16a885.html"/>
    <id>https://fxhstudy.com/article/ba16a885.html</id>
    <published>2022-02-16T13:20:35.000Z</published>
    <updated>2022-02-17T10:11:14.000Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><p>这个学期有一门算法课，所以现在打算开始比较系统地学习一些经典的算法以及思想。</p><h2 id="分而治之思想"><a href="#分而治之思想" class="headerlink" title="分而治之思想"></a>分而治之思想</h2><p>“分而治之”( Divide and conquer)方法(又称“分治术”) ，是有效算法设计中普遍采用的一种技术。</p><p>所谓“分而治之” 就是把一个复杂的算法问题按一定的“分解”方法分为等价的规模较小的若干部分，然后逐个解决，分别找出各部分的解，把各部分的解组成整个问题的解。</p><p>对于一些问题，如果我们使用枚举法，并不能满足于时间复杂度的需求，此时，分而治之法就是一个不错的选择。<br>例如对于很经典的排序问题，如果我们使用爆破枚举的方法去解决，时间复杂度是n²,而如果用归并排序(分治术)去设计的话，时间复杂度就是nlogn了。</p><p>分而治之可以用我们平常说的大事化小来理解。</p><p>而在分治术中，很经典的问题之一就是最大子数组和问题了。</p><h2 id="最大子数组和问题"><a href="#最大子数组和问题" class="headerlink" title="最大子数组和问题"></a>最大子数组和问题</h2><font color="#856363" size="4" face="Open Sans">输入：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个数组X[1..n],对于任意一对数组下标为l,r(l<=r)的非空子数组，其和记为: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S(l,r)=sum(X[i])    (l<=i<=r)<br/><br/>输出：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    求出S(l,r)的最大值，记为Smax</font><h3 id="方法一-暴力枚举"><a href="#方法一-暴力枚举" class="headerlink" title="方法一 暴力枚举"></a>方法一 暴力枚举</h3><p>意思就是在下标l-r的数组中，找出和最大的子数组。</p><p>这题难度对于没有进行过算法练习的人来讲，很容易想到的就是枚举法：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Enum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">-128</span>;<span class="hljs-comment">// 这里是将max设置为无限小</span><br><span class="hljs-keyword">int</span> temp;<br><span class="hljs-keyword">int</span> l,r,i;<br><span class="hljs-keyword">for</span>(l=<span class="hljs-number">0</span>; l&lt;n; l++)&#123;<span class="hljs-comment">// 一层循环</span><br><span class="hljs-keyword">for</span>(r=l; r&lt;n; r++)&#123;<span class="hljs-comment">// 二层循环</span><br>temp = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=l; i&lt;=r; i++)&#123;<span class="hljs-comment">// 三层循环</span><br>temp += arr[i];<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">max</span> &lt; temp)&#123;<br><span class="hljs-built_in">max</span> = temp;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;<span class="hljs-comment">// 返回找到的最大值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>暴力枚举法的总体思路就是，将每一种可能都进行遍历，选出最大值。<br>对于第一层循环，是先将数组l-r下标的数组全部进行遍历<br>对于第二层循环，是基于第一层循环下的基础上，对于含有arr[l]的子数组进行遍历<br>对于第三层循环，是将每一种可能进行全部累加</p><p>爆破枚举的时间复杂度非常高，达到了O(N³)</p><h3 id="方法二-优化枚举"><a href="#方法二-优化枚举" class="headerlink" title="方法二 优化枚举"></a>方法二 优化枚举</h3><p>仔细分析一下我们上面设计的代码，可以发现，对于第三层的循环是很多余的，存在重复计算，我们完全可以去除这一层循环。<br>思路是，对于第二层循环，我们将temp保留，这样就可以减少一次循环</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Enum_Optimize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">-128</span>;<br><span class="hljs-keyword">int</span> temp;<br><span class="hljs-keyword">int</span> l,r;<br><span class="hljs-keyword">for</span>(l=<span class="hljs-number">0</span>; l&lt;n; l++)&#123;<span class="hljs-comment">// 一层循环</span><br>temp = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(r=l; r&lt;n; r++)&#123;<span class="hljs-comment">// 二层循环</span><br>temp += arr[r];<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">max</span> &lt; temp)&#123;<br><span class="hljs-built_in">max</span> = temp;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>和暴力枚举的区别并不大，但优化之后的枚举，时间复杂度为O(N²)，相比暴力枚举大大减少</p><h3 id="方法三-分而治之"><a href="#方法三-分而治之" class="headerlink" title="方法三 分而治之"></a>方法三 分而治之</h3><p>运用分治法解决这题的思路就是，<code>分解原问题 --&gt; 解决子问题 --&gt; 合并问题解</code></p><p>先将数组的从中间分开，确定左子数组中的最大值和右子数组中的最大值，接着取存在arr[mid]和arr[mid+1]的子数组的最大值，最后合并左子数组和右子数组取三者的最大值，即为这段子数组的最大值。而其中，左子数组和右子数组则继续采用分治法来计算。</p><p>结合主要思想，我们需要的第一步就是通过递归的方法，利用树的思想，大化小，如下图所示:</p><p><img src="https://qiniuyun.fxhstudy.com/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84.png" srcset="/img/loading.gif"  title="分治法"><br/></p><p>而第二步就是当我们合并不可分割的叶子节点时，如何确定合并后的最大值。<br>这里需要解决的问题是，当我们合并两个子节点时，可以发现左子节点和右子节点合并后会影响合并后的最大值，并不是取前者或者后者的最大值。<br>可以发现，合并时取包含arr[mid]和arr[mid+1]的子数组的最大值(通过遍历mid到left，mid+1到right，取出Max[l…mid,mid+1…r])，再取max{left、mid、right}，此时便可以取出合并后的最大值了,思路如下图所示:</p><p><img src="https://qiniuyun.fxhstudy.com/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%842.png" srcset="/img/loading.gif"  title="取最大值"><br/></p><p>此数组的最大子数组和为14</p><p>分治法代码如下:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 解决合并后的数组</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CrossingSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span></span>&#123; <br><span class="hljs-keyword">int</span> Sleft = <span class="hljs-number">-128</span>;<span class="hljs-comment">// 这里是将最大值设置为无限小</span><br><span class="hljs-keyword">int</span> Sright = <span class="hljs-number">-128</span>;<br><span class="hljs-keyword">int</span> Ssum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> i,s3;<br><span class="hljs-comment">// 取出左子数组的最大值,赋值给Sleft</span><br><span class="hljs-keyword">for</span>(i=mid; i&gt;=low; i--)&#123;<br>Ssum += arr[i];<br>Sleft = Sleft &gt; Ssum ? Sleft : Ssum;<br>&#125;<br>Ssum = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 取出右子数组的最大值,赋值给Sright</span><br><span class="hljs-keyword">for</span>(i=mid+<span class="hljs-number">1</span>; i&lt;=high; i++)&#123;<br>Ssum += arr[i];<br>Sright = Sright &gt; Ssum ? Sright : Ssum;<br>&#125;<br><span class="hljs-comment">// 返回Sleft+Sright</span><br>s3 = Sleft + Sright;<br>  <span class="hljs-keyword">return</span> s3;<br>&#125;<br><br><span class="hljs-comment">// 分解原问题</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;<br><span class="hljs-keyword">if</span>(low == high)&#123;<br><span class="hljs-keyword">return</span> arr[low];<br>&#125;<br><span class="hljs-keyword">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> s1 = MaxSubArray(arr, low, mid);<br><span class="hljs-keyword">int</span> s2 = MaxSubArray(arr, mid+<span class="hljs-number">1</span>, high);<br><span class="hljs-keyword">int</span> s3 = CrossingSubArray(arr, low, mid, high);<br><span class="hljs-keyword">int</span> result = s1 &gt; s2 ? (s1 &gt; s3 ? s1 : s3) : (s2 &gt; s3 ? s2 : s3);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">7</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-5</span>&#125;;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//int max_arr = Enum(arr, num);</span><br><span class="hljs-comment">//int max_arr = Enum_Optimize(arr, num);</span><br><span class="hljs-keyword">int</span> max_arr = MaxSubArray(arr, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, max_arr);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出如下:</p><figure class="highlight cmd"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmd"><span class="hljs-number">14</span><br></code></pre></div></td></tr></table></figure><p>分析时间复杂度的话，可以看出，其主要时间是花费在递归和解决合并子问题，其时间复杂度为nlogn</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们分析了最大子数组问题，可以发现从枚举思想到分治法思想，算法所用到的时间复杂度大大降低，虽不易理解，但也不算太难。(之后我也会介绍关于动态规划的思想怎么去解决这个问题，此时便可以将时间复杂度降低到n，可以期待一下)</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;

&lt;p&gt;这个学期有一门算法课，所以现在打算开始比较系统地学习一些经典的算法以及思想。&lt;/p&gt;
&lt;h2 id=&quot;分而治之思想&quot;&gt;&lt;a href=&quot;#分而治之思想&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="经典算法" scheme="https://fxhstudy.com/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fxhstudy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>总结2021</title>
    <link href="https://fxhstudy.com/article/d6f478e0.html"/>
    <id>https://fxhstudy.com/article/d6f478e0.html</id>
    <published>2021-12-31T14:56:15.000Z</published>
    <updated>2021-12-31T15:37:04.000Z</updated>
    
    <content type="html"><![CDATA[<font color="#856363" size="4" face="Open Sans"><p>很久没有更新博客了，今天是2021的最后一天，现在的我在看楚大的直播，大学的三年，都是看他的直播跨年的(明年继续!)。<br>然后最后的一个小时，我想总结一下我的2021!<br>这一年我一共更新了64篇博客，一总结感觉好多啊!虽然浪费了很多时间，但这一年也没有一事无成!嘻嘻<br>没想到这一年过得这么快，这一年发生了很多，平凡而又不平凡。这一年，我获得了很多小小的成就，也有很多遗憾。<br>但是这些都没有关系了，一切都已经过去了。<br>明天也就是2022了，新的一年，新的起点!<br>其实日子还是一样的过，并没有今天和明天就会有什么不同了。但是生活总要有一些仪式感嘛!<br>今天看了一下2020的总结，2020年确实是我最难过的一年，在2020年的总结中，我写到”2021，希望它不要那么糟”<br>生活是这样的，不会总是那么差的，总会好起来的。今年就是对我而言就是一个很棒的一年，明年肯定会更好的!<br>我希望明年我的年度总结能够比今年好，明年就要考研了，希望一次上岸!</p><p>如果2021年的你过的并不好,甚至可以说很糟糕,不要为此而感到悲伤。请记住,生活嘛,不会总是那么差的!<br>当然如果你这一年过的很充实,那么我更希望你能在2022这一年，能够继续保持这种状态!</p><p>最后,引用一下我在2020总结写的一句话:”如果你能看这段话，祝你幸福。”<br></font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font color=&quot;#856363&quot; size=&quot;4&quot; face=&quot;Open Sans&quot;&gt;

&lt;p&gt;很久没有更新博客了，今天是2021的最后一天，现在的我在看楚大的直播，大学的三年，都是看他的直播跨年的(明年继续!)。&lt;br&gt;然后最后的一个小时，我想总结一下我的2021!&lt;
      
    
    </summary>
    
    
      <category term="生活" scheme="https://fxhstudy.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="个人" scheme="https://fxhstudy.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>总结一下[11·25]</title>
    <link href="https://fxhstudy.com/article/5f04e18c.html"/>
    <id>https://fxhstudy.com/article/5f04e18c.html</id>
    <published>2021-11-25T15:36:48.000Z</published>
    <updated>2021-12-16T14:50:48.000Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><p>说点好消息，上次的信息安全攻防赛和作品赛都拿了安徽省省一，而且我都是队长，感觉还不错<br>也就是说我现在是一个国二，三个省一和一个省二(计算机设计大赛的省一和国二也算进去了)<br>我对自己所取得成绩还是比较满意的，然后现在也还在准备计算机设计大赛的项目，准备在寒假之前做完，<br>现在基本上已经成型了，区块链部分这段时间也完成了最重要的部分了，就差应用了</p><p>先放几张成功跑起来的图</p><p><img src="https://qiniuyun.fxhstudy.com/%E5%8C%BA%E5%9D%97%E9%93%BE.png" srcset="/img/loading.gif"><br/></p><p><img src="https://qiniuyun.fxhstudy.com/%E5%8C%BA%E5%9D%97%E9%93%BE1.png" srcset="/img/loading.gif"><br/></p><p><img src="https://qiniuyun.fxhstudy.com/%E5%8C%BA%E5%9D%97%E9%93%BE2.png" srcset="/img/loading.gif"><br/></p><p><img src="https://qiniuyun.fxhstudy.com/%E5%8C%BA%E5%9D%97%E9%93%BE3.png" srcset="/img/loading.gif"><br/></p><p><img src="https://qiniuyun.fxhstudy.com/%E5%8C%BA%E5%9D%97%E9%93%BE4.png" srcset="/img/loading.gif"><br/></p><p>u1s1，还是很自豪的，之前以为区块链离我非常远，可能也就比特币才了解一下<br>没想到，我现在也用区块链做出了两个项目了。<br>真的，如果我考上研了，实在不行我就去搞研究去了，能往上读就往上读。不搞开发了，现在搞开发太竞争压力实在太大了。。。</p><p>当然，考不上的话，还是乖乖搞开发吧</p><p>这段时间比较忙吧，接下来也是，快要期末了，课设+期末考试<br>然后项目虽然做的差不多了，但很多细节还是需要考虑的<br>计算机设计大赛注重于系统的逻辑，而不在于你所用的的技术多么高级<br>逻辑方面一定要设计好，然后立意和落实性最好也要好，这样才能拿到比较好的成绩。</p><p>大致就是这么多，博客有时间就更，没时间就往后延期吧。<br>前段时间准备介绍一些有关于操作系统的知识，包括一些进程调度算法、经典进程同步算法，以及避免死锁的银行家算法<br>然后现在也找不到太多时间去介绍了，等后面看看有没有时间吧</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;

&lt;p&gt;说点好消息，上次的信息安全攻防赛和作品赛都拿了安徽省省一，而且我都是队长，感觉还不错&lt;br&gt;也就是说我现在是一个国二，三个省一和一个省二(计算机设计大赛的省一和国二也算进去了)&lt;br&gt;我对自己所取得成绩
      
    
    </summary>
    
    
      <category term="生活" scheme="https://fxhstudy.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="个人" scheme="https://fxhstudy.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>搭建区块链浏览器所遇到的问题3-如何更改linux中gradle的版本</title>
    <link href="https://fxhstudy.com/article/bbca77fb.html"/>
    <id>https://fxhstudy.com/article/bbca77fb.html</id>
    <published>2021-11-25T15:01:29.000Z</published>
    <updated>2021-11-25T15:35:06.000Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><p>单独拿出来说是因为这又是一个悲惨的故事了，<br>关于如何更改linux中gradle的版本这个我问题，我查非常多的资料<br>唉，也花了一个多小时。。。</p><p>Ubuntu中如果让系统帮你自己安装Gradle要么是</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">sudo snap <span class="hljs-keyword">install</span> Gradle<br></code></pre></div></td></tr></table></figure><p>这里安装的是7.0以上的版本，不符合我们需要的7.0以下的版本</p><p>要么是</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> Gradle<br></code></pre></div></td></tr></table></figure><p>这里安装的是4.10一下的版本，也不符合官方给的5.0以上的需求。。。</p><p>那只有我们自己找了，好不容易好不容易好不容易将Gradle安装好了，环境变量也配置好了之后<br>并且我将原先安装的Gradle7.0版本卸载之后，满怀欣喜的输入 <code>gradle -v</code></p><p>然后。。。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">gradle：未找到命令<br></code></pre></div></td></tr></table></figure><p>一种植物。。。<br>这谁顶得住啊，明明环境变量都配置好了还是这样</p><p>然后继续查资料。。。然后一直在找这个问题</p><p>最后什么都没有解决我的问题。。。根本没找到，用了snap卸载的方法也还是不行</p><p>我急中生智，先用</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> Gradle<br></code></pre></div></td></tr></table></figure><p>命令安装4.10版本的Gradle，然后在</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">sudo apt <span class="hljs-builtin-name">remove</span> Gradle<br></code></pre></div></td></tr></table></figure><p>接着，我再自己下载Gradle压缩包，配置环境，没想到竟然成了。。。</p><p><img src="https://qiniuyun.fxhstudy.com/bbca77fb_2.png" srcset="/img/loading.gif"><br/></p><p>Gradle命令是配好了</p><p>但接下来又遇到了其他问题，运行脚本的时候，又爆出这个错误：</p><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-string">bash:</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/gradle-5.4.1-all/</span>gradle<span class="hljs-number">-5.4</span><span class="hljs-number">.1</span><span class="hljs-regexp">/bin/</span><span class="hljs-string">gradle:</span> 权限不够<br></code></pre></div></td></tr></table></figure><p>这个还好，能看得懂是为什么，就是权限不够：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">chmod +x <span class="hljs-variable">$&#123;location&#125;</span><span class="hljs-regexp">/gradle-4.9/</span>bin<span class="hljs-regexp">/gradle</span><br></code></pre></div></td></tr></table></figure><p>于是就成功了😭，放一下我解决这个问题查找的博文，还有很多小的地方就不介绍了，主要是这三个问题比较难解决，其他的也花了很多时间，但网上也有相应的资料，MySQL的安装，java环境配置，python环境配置以及PyMySQL的安装</p><p><img src="https://qiniuyun.fxhstudy.com/bbca77fb_1.png" srcset="/img/loading.gif"><br/></p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;

&lt;p&gt;单独拿出来说是因为这又是一个悲惨的故事了，&lt;br&gt;关于如何更改linux中gradle的版本这个我问题，我查非常多的资料&lt;br&gt;唉，也花了一个多小时。。。&lt;/p&gt;
&lt;p&gt;Ubuntu中如果让系统帮你自己
      
    
    </summary>
    
    
      <category term="区块链浏览器" scheme="https://fxhstudy.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="区块链" scheme="https://fxhstudy.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>搭建区块链浏览器所遇到的问题2-Plugin with id &#39;maven&#39; not found</title>
    <link href="https://fxhstudy.com/article/bd2bf688.html"/>
    <id>https://fxhstudy.com/article/bd2bf688.html</id>
    <published>2021-11-25T14:17:00.000Z</published>
    <updated>2021-11-25T15:06:22.000Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><p>开始尝试的是一键部署，失败了几次之后，然后打算手动部署吧，先部署后端，没有截图了，然后根据官网的命令</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">gradle build</span><br></code></pre></div></td></tr></table></figure><p>运行之后，报错。。。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">Plugin <span class="hljs-keyword">with</span> <span class="hljs-keyword">id</span> <span class="hljs-string">'maven'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">found</span><br></code></pre></div></td></tr></table></figure><p>找不到id为maven的插件？<br>我顿时懵逼了，需要maven插件嘛，我只在Spring boot中用到过maven，所以还需要maven环境吗？</p><p><img src="https://qiniuyun.fxhstudy.com/bd2bf688_2.PNG" srcset="/img/loading.gif"><br/></p><p>看了源码之后，确实需要</p><p>但是看了官网的环境要求，并没有要求啊</p><p><img src="https://qiniuyun.fxhstudy.com/bd2bf688_3.PNG" srcset="/img/loading.gif"><br/></p><p>好吧，可能是他们环境里面早就有了，咱也不知道，咱也不敢问啊！</p><p>于是一顿操作后，配置好maven环境后，再次尝试，还是失败了。。。<br>唉，太难了。<br>接着搜资料，但是现在有关于区块链的搭建也到的问题解答比较少<br>只能慢慢找了</p><p>找了很久很久，这个问题找了有一个半小时</p><p><img src="https://qiniuyun.fxhstudy.com/bd2bf688_4.png" srcset="/img/loading.gif"><br/></p><p>这是虚拟机的截图，还有本机的就不放上去了。</p><p>基本上找不到找不到找不到有关的信息，然后终于让我找到了</p><p><img src="https://qiniuyun.fxhstudy.com/bd2bf688_5.png" srcset="/img/loading.gif"><br/></p><p>原因是，Gradle 7.版本将maven插件移除了,好了知道了原因，怎么解决呢？<br>下一篇就说一下怎么解决<br>为什么要分两篇呢？因为这又是一个悲惨的故事了。。。</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;

&lt;p&gt;开始尝试的是一键部署，失败了几次之后，然后打算手动部署吧，先部署后端，没有截图了，然后根据官网的命令&lt;/p&gt;
&lt;figure class=&quot;highlight ebnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
      <category term="区块链浏览器" scheme="https://fxhstudy.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="区块链" scheme="https://fxhstudy.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>搭建区块链浏览器所遇到的问题1-MySQL登陆时权限问题</title>
    <link href="https://fxhstudy.com/article/9bcf702.html"/>
    <id>https://fxhstudy.com/article/9bcf702.html</id>
    <published>2021-11-25T12:57:59.000Z</published>
    <updated>2021-11-25T14:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<font size="4" face="PingFang SC"><p>这段时间不是做项目嘛，项目已经做的基本上差不多了，但是想要拿到国二以上的奖，还是有些不够的。然后想用到区块链的知识，因为我之前的作品赛的时候用到的就是区块链嘛，所以有一些基础。最近就都在弄区块链的东西，前前后后加起来花了大概几十个小时吧。终于让我把区块链浏览器的环境搭建好了，并且现在终于跑起来了。<br>搭建的时候遇到了很多很多的问题，我至少三次想过放弃搭建了，因为实在是太难受了，各种问题，还好坚持下来了，昨天晚上十一点吧，跑起来了:)<br>接下来的博客会写一些我搭建过程中遇到的问题。不会按照遇到的顺序来，想到了就先写下来</p><hr/><p>我搭建的时候是用官方给的一键部署的脚本来搭建的，<br>环境是在Ubuntu中搭建的，然后在执行python脚本的时候遇到了下面的问题</p><p><img src="https://qiniuyun.fxhstudy.com/9bcf702_1.PNG" srcset="/img/loading.gif"><br/></p><p>此时你会怎么想，用户名/密码错了?<br>我是这样想的，然后又去MySQL中看了用户名和密码没有错,感觉应该不是这个问题，还以为是Mysql的原因，<br>卸载再重装。。。<br>后面又遇到这个问题，，，<br>想着会不会是权限的问题，因为我发现，我不是以root的角色登录的<br>并且每一次登录MySQL的时候，都是</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo mysql -u root -p</span><br></code></pre></div></td></tr></table></figure><p>才会登录成功，不然会报以下的错误</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-builtin-name">ERROR</span> 1690(28000): access denied <span class="hljs-keyword">for</span><span class="hljs-built_in"> user </span><span class="hljs-string">'root'</span>@<span class="hljs-string">'localhost'</span><br></code></pre></div></td></tr></table></figure><p>这里必须要sudo，才可以登录，这是因为MySQL设置了用户验证。。。</p><p>怎么解决的呢<br>一、首先我们先登录数据库</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo mysql -u root -p</span><br></code></pre></div></td></tr></table></figure><p>二、再执行一下语句，修改mysql登陆的验证方式</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">ALTER<span class="hljs-built_in"> USER </span><span class="hljs-string">'root'</span>@<span class="hljs-string">'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span class="hljs-string">'你的密码'</span>;<br></code></pre></div></td></tr></table></figure><p>三、更新权限</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;<br></code></pre></div></td></tr></table></figure><p><img src="https://qiniuyun.fxhstudy.com/9bcf702_2.PNG" srcset="/img/loading.gif"><br/></p><p>可以看到，我第二次登录的时候，就不在需要再以管理员身份执行了</p><p>然后执行脚本，成功了</p><p><img src="https://qiniuyun.fxhstudy.com/9bcf702_3.PNG" srcset="/img/loading.gif"><br/></p><p>这是跑起来遇到的最后一个问题。。。</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot; face=&quot;PingFang SC&quot;&gt;

&lt;p&gt;这段时间不是做项目嘛，项目已经做的基本上差不多了，但是想要拿到国二以上的奖，还是有些不够的。然后想用到区块链的知识，因为我之前的作品赛的时候用到的就是区块链嘛，所以有一些基础。最近就都在弄区块链的东西，
      
    
    </summary>
    
    
      <category term="区块链浏览器" scheme="https://fxhstudy.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="区块链" scheme="https://fxhstudy.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
</feed>
